// Generated by `wit-bindgen` 0.51.0. DO NOT EDIT!
//
// This code was generated from the following packages:
//     wasi:io@0.2.0
//     wasi:clocks@0.2.0
//     wasi:random@0.2.0
//     wasi:cli@0.2.0
//     wasi:http@0.2.0
//     jamesstocktonj1:componentize-sdk

package wasi_http_types

import (
	"github.com/bytecodealliance/wit-bindgen/wit_runtime"
	"github.com/bytecodealliance/wit-bindgen/wit_types"
	"github.com/jamesstocktonj1/componentize-sdk/gen/wasi_io_error"
	"github.com/jamesstocktonj1/componentize-sdk/gen/wasi_io_poll"
	"github.com/jamesstocktonj1/componentize-sdk/gen/wasi_io_streams"
	"runtime"
	"unsafe"
)

type Duration = uint64
type InputStream = wasi_io_streams.InputStream
type OutputStream = wasi_io_streams.OutputStream
type IoError = wasi_io_error.Error
type Pollable = wasi_io_poll.Pollable

const (
	MethodGet     uint8 = 0
	MethodHead    uint8 = 1
	MethodPost    uint8 = 2
	MethodPut     uint8 = 3
	MethodDelete  uint8 = 4
	MethodConnect uint8 = 5
	MethodOptions uint8 = 6
	MethodTrace   uint8 = 7
	MethodPatch   uint8 = 8
	MethodOther   uint8 = 9
)

// This type corresponds to HTTP standard Methods.
type Method struct {
	tag   uint8
	value any
}

func (self Method) Tag() uint8 {
	return self.tag
}

func (self Method) Other() string {
	if self.tag != MethodOther {
		panic("tag mismatch")
	}
	return self.value.(string)
}

func MakeMethodGet() Method {
	return Method{MethodGet, nil}
}
func MakeMethodHead() Method {
	return Method{MethodHead, nil}
}
func MakeMethodPost() Method {
	return Method{MethodPost, nil}
}
func MakeMethodPut() Method {
	return Method{MethodPut, nil}
}
func MakeMethodDelete() Method {
	return Method{MethodDelete, nil}
}
func MakeMethodConnect() Method {
	return Method{MethodConnect, nil}
}
func MakeMethodOptions() Method {
	return Method{MethodOptions, nil}
}
func MakeMethodTrace() Method {
	return Method{MethodTrace, nil}
}
func MakeMethodPatch() Method {
	return Method{MethodPatch, nil}
}
func MakeMethodOther(value string) Method {
	return Method{MethodOther, value}
}

const (
	SchemeHttp  uint8 = 0
	SchemeHttps uint8 = 1
	SchemeOther uint8 = 2
)

// This type corresponds to HTTP standard Related Schemes.
type Scheme struct {
	tag   uint8
	value any
}

func (self Scheme) Tag() uint8 {
	return self.tag
}

func (self Scheme) Other() string {
	if self.tag != SchemeOther {
		panic("tag mismatch")
	}
	return self.value.(string)
}

func MakeSchemeHttp() Scheme {
	return Scheme{SchemeHttp, nil}
}
func MakeSchemeHttps() Scheme {
	return Scheme{SchemeHttps, nil}
}
func MakeSchemeOther(value string) Scheme {
	return Scheme{SchemeOther, value}
}

// Defines the case payload type for `DNS-error` above:
type DnsErrorPayload struct {
	Rcode    wit_types.Option[string]
	InfoCode wit_types.Option[uint16]
}

// Defines the case payload type for `TLS-alert-received` above:
type TlsAlertReceivedPayload struct {
	AlertId      wit_types.Option[uint8]
	AlertMessage wit_types.Option[string]
}

// Defines the case payload type for `HTTP-response-{header,trailer}-size` above:
type FieldSizePayload struct {
	FieldName wit_types.Option[string]
	FieldSize wit_types.Option[uint32]
}

const (
	ErrorCodeDnsTimeout                     uint8 = 0
	ErrorCodeDnsError                       uint8 = 1
	ErrorCodeDestinationNotFound            uint8 = 2
	ErrorCodeDestinationUnavailable         uint8 = 3
	ErrorCodeDestinationIpProhibited        uint8 = 4
	ErrorCodeDestinationIpUnroutable        uint8 = 5
	ErrorCodeConnectionRefused              uint8 = 6
	ErrorCodeConnectionTerminated           uint8 = 7
	ErrorCodeConnectionTimeout              uint8 = 8
	ErrorCodeConnectionReadTimeout          uint8 = 9
	ErrorCodeConnectionWriteTimeout         uint8 = 10
	ErrorCodeConnectionLimitReached         uint8 = 11
	ErrorCodeTlsProtocolError               uint8 = 12
	ErrorCodeTlsCertificateError            uint8 = 13
	ErrorCodeTlsAlertReceived               uint8 = 14
	ErrorCodeHttpRequestDenied              uint8 = 15
	ErrorCodeHttpRequestLengthRequired      uint8 = 16
	ErrorCodeHttpRequestBodySize            uint8 = 17
	ErrorCodeHttpRequestMethodInvalid       uint8 = 18
	ErrorCodeHttpRequestUriInvalid          uint8 = 19
	ErrorCodeHttpRequestUriTooLong          uint8 = 20
	ErrorCodeHttpRequestHeaderSectionSize   uint8 = 21
	ErrorCodeHttpRequestHeaderSize          uint8 = 22
	ErrorCodeHttpRequestTrailerSectionSize  uint8 = 23
	ErrorCodeHttpRequestTrailerSize         uint8 = 24
	ErrorCodeHttpResponseIncomplete         uint8 = 25
	ErrorCodeHttpResponseHeaderSectionSize  uint8 = 26
	ErrorCodeHttpResponseHeaderSize         uint8 = 27
	ErrorCodeHttpResponseBodySize           uint8 = 28
	ErrorCodeHttpResponseTrailerSectionSize uint8 = 29
	ErrorCodeHttpResponseTrailerSize        uint8 = 30
	ErrorCodeHttpResponseTransferCoding     uint8 = 31
	ErrorCodeHttpResponseContentCoding      uint8 = 32
	ErrorCodeHttpResponseTimeout            uint8 = 33
	ErrorCodeHttpUpgradeFailed              uint8 = 34
	ErrorCodeHttpProtocolError              uint8 = 35
	ErrorCodeLoopDetected                   uint8 = 36
	ErrorCodeConfigurationError             uint8 = 37
	// This is a catch-all error for anything that doesn't fit cleanly into a
	// more specific case. It also includes an optional string for an
	// unstructured description of the error. Users should not depend on the
	// string for diagnosing errors, as it's not required to be consistent
	// between implementations.
	ErrorCodeInternalError uint8 = 38
)

// These cases are inspired by the IANA HTTP Proxy Error Types:
// https://www.iana.org/assignments/http-proxy-status/http-proxy-status.xhtml#table-http-proxy-error-types
type ErrorCode struct {
	tag   uint8
	value any
}

func (self ErrorCode) Tag() uint8 {
	return self.tag
}

func (self ErrorCode) DnsError() DnsErrorPayload {
	if self.tag != ErrorCodeDnsError {
		panic("tag mismatch")
	}
	return self.value.(DnsErrorPayload)
}
func (self ErrorCode) TlsAlertReceived() TlsAlertReceivedPayload {
	if self.tag != ErrorCodeTlsAlertReceived {
		panic("tag mismatch")
	}
	return self.value.(TlsAlertReceivedPayload)
}
func (self ErrorCode) HttpRequestBodySize() wit_types.Option[uint64] {
	if self.tag != ErrorCodeHttpRequestBodySize {
		panic("tag mismatch")
	}
	return self.value.(wit_types.Option[uint64])
}
func (self ErrorCode) HttpRequestHeaderSectionSize() wit_types.Option[uint32] {
	if self.tag != ErrorCodeHttpRequestHeaderSectionSize {
		panic("tag mismatch")
	}
	return self.value.(wit_types.Option[uint32])
}
func (self ErrorCode) HttpRequestHeaderSize() wit_types.Option[FieldSizePayload] {
	if self.tag != ErrorCodeHttpRequestHeaderSize {
		panic("tag mismatch")
	}
	return self.value.(wit_types.Option[FieldSizePayload])
}
func (self ErrorCode) HttpRequestTrailerSectionSize() wit_types.Option[uint32] {
	if self.tag != ErrorCodeHttpRequestTrailerSectionSize {
		panic("tag mismatch")
	}
	return self.value.(wit_types.Option[uint32])
}
func (self ErrorCode) HttpRequestTrailerSize() FieldSizePayload {
	if self.tag != ErrorCodeHttpRequestTrailerSize {
		panic("tag mismatch")
	}
	return self.value.(FieldSizePayload)
}
func (self ErrorCode) HttpResponseHeaderSectionSize() wit_types.Option[uint32] {
	if self.tag != ErrorCodeHttpResponseHeaderSectionSize {
		panic("tag mismatch")
	}
	return self.value.(wit_types.Option[uint32])
}
func (self ErrorCode) HttpResponseHeaderSize() FieldSizePayload {
	if self.tag != ErrorCodeHttpResponseHeaderSize {
		panic("tag mismatch")
	}
	return self.value.(FieldSizePayload)
}
func (self ErrorCode) HttpResponseBodySize() wit_types.Option[uint64] {
	if self.tag != ErrorCodeHttpResponseBodySize {
		panic("tag mismatch")
	}
	return self.value.(wit_types.Option[uint64])
}
func (self ErrorCode) HttpResponseTrailerSectionSize() wit_types.Option[uint32] {
	if self.tag != ErrorCodeHttpResponseTrailerSectionSize {
		panic("tag mismatch")
	}
	return self.value.(wit_types.Option[uint32])
}
func (self ErrorCode) HttpResponseTrailerSize() FieldSizePayload {
	if self.tag != ErrorCodeHttpResponseTrailerSize {
		panic("tag mismatch")
	}
	return self.value.(FieldSizePayload)
}
func (self ErrorCode) HttpResponseTransferCoding() wit_types.Option[string] {
	if self.tag != ErrorCodeHttpResponseTransferCoding {
		panic("tag mismatch")
	}
	return self.value.(wit_types.Option[string])
}
func (self ErrorCode) HttpResponseContentCoding() wit_types.Option[string] {
	if self.tag != ErrorCodeHttpResponseContentCoding {
		panic("tag mismatch")
	}
	return self.value.(wit_types.Option[string])
}
func (self ErrorCode) InternalError() wit_types.Option[string] {
	if self.tag != ErrorCodeInternalError {
		panic("tag mismatch")
	}
	return self.value.(wit_types.Option[string])
}

func MakeErrorCodeDnsTimeout() ErrorCode {
	return ErrorCode{ErrorCodeDnsTimeout, nil}
}
func MakeErrorCodeDnsError(value DnsErrorPayload) ErrorCode {
	return ErrorCode{ErrorCodeDnsError, value}
}
func MakeErrorCodeDestinationNotFound() ErrorCode {
	return ErrorCode{ErrorCodeDestinationNotFound, nil}
}
func MakeErrorCodeDestinationUnavailable() ErrorCode {
	return ErrorCode{ErrorCodeDestinationUnavailable, nil}
}
func MakeErrorCodeDestinationIpProhibited() ErrorCode {
	return ErrorCode{ErrorCodeDestinationIpProhibited, nil}
}
func MakeErrorCodeDestinationIpUnroutable() ErrorCode {
	return ErrorCode{ErrorCodeDestinationIpUnroutable, nil}
}
func MakeErrorCodeConnectionRefused() ErrorCode {
	return ErrorCode{ErrorCodeConnectionRefused, nil}
}
func MakeErrorCodeConnectionTerminated() ErrorCode {
	return ErrorCode{ErrorCodeConnectionTerminated, nil}
}
func MakeErrorCodeConnectionTimeout() ErrorCode {
	return ErrorCode{ErrorCodeConnectionTimeout, nil}
}
func MakeErrorCodeConnectionReadTimeout() ErrorCode {
	return ErrorCode{ErrorCodeConnectionReadTimeout, nil}
}
func MakeErrorCodeConnectionWriteTimeout() ErrorCode {
	return ErrorCode{ErrorCodeConnectionWriteTimeout, nil}
}
func MakeErrorCodeConnectionLimitReached() ErrorCode {
	return ErrorCode{ErrorCodeConnectionLimitReached, nil}
}
func MakeErrorCodeTlsProtocolError() ErrorCode {
	return ErrorCode{ErrorCodeTlsProtocolError, nil}
}
func MakeErrorCodeTlsCertificateError() ErrorCode {
	return ErrorCode{ErrorCodeTlsCertificateError, nil}
}
func MakeErrorCodeTlsAlertReceived(value TlsAlertReceivedPayload) ErrorCode {
	return ErrorCode{ErrorCodeTlsAlertReceived, value}
}
func MakeErrorCodeHttpRequestDenied() ErrorCode {
	return ErrorCode{ErrorCodeHttpRequestDenied, nil}
}
func MakeErrorCodeHttpRequestLengthRequired() ErrorCode {
	return ErrorCode{ErrorCodeHttpRequestLengthRequired, nil}
}
func MakeErrorCodeHttpRequestBodySize(value wit_types.Option[uint64]) ErrorCode {
	return ErrorCode{ErrorCodeHttpRequestBodySize, value}
}
func MakeErrorCodeHttpRequestMethodInvalid() ErrorCode {
	return ErrorCode{ErrorCodeHttpRequestMethodInvalid, nil}
}
func MakeErrorCodeHttpRequestUriInvalid() ErrorCode {
	return ErrorCode{ErrorCodeHttpRequestUriInvalid, nil}
}
func MakeErrorCodeHttpRequestUriTooLong() ErrorCode {
	return ErrorCode{ErrorCodeHttpRequestUriTooLong, nil}
}
func MakeErrorCodeHttpRequestHeaderSectionSize(value wit_types.Option[uint32]) ErrorCode {
	return ErrorCode{ErrorCodeHttpRequestHeaderSectionSize, value}
}
func MakeErrorCodeHttpRequestHeaderSize(value wit_types.Option[FieldSizePayload]) ErrorCode {
	return ErrorCode{ErrorCodeHttpRequestHeaderSize, value}
}
func MakeErrorCodeHttpRequestTrailerSectionSize(value wit_types.Option[uint32]) ErrorCode {
	return ErrorCode{ErrorCodeHttpRequestTrailerSectionSize, value}
}
func MakeErrorCodeHttpRequestTrailerSize(value FieldSizePayload) ErrorCode {
	return ErrorCode{ErrorCodeHttpRequestTrailerSize, value}
}
func MakeErrorCodeHttpResponseIncomplete() ErrorCode {
	return ErrorCode{ErrorCodeHttpResponseIncomplete, nil}
}
func MakeErrorCodeHttpResponseHeaderSectionSize(value wit_types.Option[uint32]) ErrorCode {
	return ErrorCode{ErrorCodeHttpResponseHeaderSectionSize, value}
}
func MakeErrorCodeHttpResponseHeaderSize(value FieldSizePayload) ErrorCode {
	return ErrorCode{ErrorCodeHttpResponseHeaderSize, value}
}
func MakeErrorCodeHttpResponseBodySize(value wit_types.Option[uint64]) ErrorCode {
	return ErrorCode{ErrorCodeHttpResponseBodySize, value}
}
func MakeErrorCodeHttpResponseTrailerSectionSize(value wit_types.Option[uint32]) ErrorCode {
	return ErrorCode{ErrorCodeHttpResponseTrailerSectionSize, value}
}
func MakeErrorCodeHttpResponseTrailerSize(value FieldSizePayload) ErrorCode {
	return ErrorCode{ErrorCodeHttpResponseTrailerSize, value}
}
func MakeErrorCodeHttpResponseTransferCoding(value wit_types.Option[string]) ErrorCode {
	return ErrorCode{ErrorCodeHttpResponseTransferCoding, value}
}
func MakeErrorCodeHttpResponseContentCoding(value wit_types.Option[string]) ErrorCode {
	return ErrorCode{ErrorCodeHttpResponseContentCoding, value}
}
func MakeErrorCodeHttpResponseTimeout() ErrorCode {
	return ErrorCode{ErrorCodeHttpResponseTimeout, nil}
}
func MakeErrorCodeHttpUpgradeFailed() ErrorCode {
	return ErrorCode{ErrorCodeHttpUpgradeFailed, nil}
}
func MakeErrorCodeHttpProtocolError() ErrorCode {
	return ErrorCode{ErrorCodeHttpProtocolError, nil}
}
func MakeErrorCodeLoopDetected() ErrorCode {
	return ErrorCode{ErrorCodeLoopDetected, nil}
}
func MakeErrorCodeConfigurationError() ErrorCode {
	return ErrorCode{ErrorCodeConfigurationError, nil}
}
func MakeErrorCodeInternalError(value wit_types.Option[string]) ErrorCode {
	return ErrorCode{ErrorCodeInternalError, value}
}

const (
	// This error indicates that a `field-key` or `field-value` was
	// syntactically invalid when used with an operation that sets headers in a
	// `fields`.
	HeaderErrorInvalidSyntax uint8 = 0
	// This error indicates that a forbidden `field-key` was used when trying
	// to set a header in a `fields`.
	HeaderErrorForbidden uint8 = 1
	// This error indicates that the operation on the `fields` was not
	// permitted because the fields are immutable.
	HeaderErrorImmutable uint8 = 2
)

// This type enumerates the different kinds of errors that may occur when
// setting or appending to a `fields` resource.
type HeaderError struct {
	tag   uint8
	value any
}

func (self HeaderError) Tag() uint8 {
	return self.tag
}

func MakeHeaderErrorInvalidSyntax() HeaderError {
	return HeaderError{HeaderErrorInvalidSyntax, nil}
}
func MakeHeaderErrorForbidden() HeaderError {
	return HeaderError{HeaderErrorForbidden, nil}
}
func MakeHeaderErrorImmutable() HeaderError {
	return HeaderError{HeaderErrorImmutable, nil}
}

// Field keys are always strings.
type FieldKey = string

// Field values should always be ASCII strings. However, in
// reality, HTTP implementations often have to interpret malformed values,
// so they are provided as a list of bytes.
type FieldValue = []uint8

//go:wasmimport wasi:http/types@0.2.0 [resource-drop]fields
func resourceDropFields(handle int32)

// This following block defines the `fields` resource which corresponds to
// HTTP standard Fields. Fields are a common representation used for both
// Headers and Trailers.
//
// A `fields` may be mutable or immutable. A `fields` created using the
// constructor, `from-list`, or `clone` will be mutable, but a `fields`
// resource given by other means (including, but not limited to,
// `incoming-request.headers`, `outgoing-request.headers`) might be be
// immutable. In an immutable fields, the `set`, `append`, and `delete`
// operations will fail with `header-error.immutable`.
type Fields struct {
	handle *wit_runtime.Handle
}

func (self *Fields) TakeHandle() int32 {
	return self.handle.Take()
}

func (self *Fields) SetHandle(handle int32) {
	self.handle.Set(handle)
}

func (self *Fields) Handle() int32 {
	return self.handle.Use()
}

func (self *Fields) Drop() {
	handle := self.handle.TakeOrNil()
	if handle != 0 {
		resourceDropFields(handle)
	}
}

func FieldsFromOwnHandle(handleValue int32) *Fields {
	handle := wit_runtime.MakeHandle(handleValue)
	value := &Fields{handle}
	runtime.AddCleanup(value, func(_ int) {
		handleValue := handle.TakeOrNil()
		if handleValue != 0 {
			resourceDropFields(handleValue)
		}
	}, 0)
	return value
}

func FieldsFromBorrowHandle(handleValue int32) *Fields {
	return FieldsFromOwnHandle(handleValue)
}

// Headers is an alias for Fields.
type Headers = Fields

// Trailers is an alias for Fields.
type Trailers = Fields

//go:wasmimport wasi:http/types@0.2.0 [resource-drop]incoming-request
func resourceDropIncomingRequest(handle int32)

// Represents an incoming HTTP Request.
type IncomingRequest struct {
	handle *wit_runtime.Handle
}

func (self *IncomingRequest) TakeHandle() int32 {
	return self.handle.Take()
}

func (self *IncomingRequest) SetHandle(handle int32) {
	self.handle.Set(handle)
}

func (self *IncomingRequest) Handle() int32 {
	return self.handle.Use()
}

func (self *IncomingRequest) Drop() {
	handle := self.handle.TakeOrNil()
	if handle != 0 {
		resourceDropIncomingRequest(handle)
	}
}

func IncomingRequestFromOwnHandle(handleValue int32) *IncomingRequest {
	handle := wit_runtime.MakeHandle(handleValue)
	value := &IncomingRequest{handle}
	runtime.AddCleanup(value, func(_ int) {
		handleValue := handle.TakeOrNil()
		if handleValue != 0 {
			resourceDropIncomingRequest(handleValue)
		}
	}, 0)
	return value
}

func IncomingRequestFromBorrowHandle(handleValue int32) *IncomingRequest {
	return IncomingRequestFromOwnHandle(handleValue)
}

//go:wasmimport wasi:http/types@0.2.0 [resource-drop]outgoing-request
func resourceDropOutgoingRequest(handle int32)

// Represents an outgoing HTTP Request.
type OutgoingRequest struct {
	handle *wit_runtime.Handle
}

func (self *OutgoingRequest) TakeHandle() int32 {
	return self.handle.Take()
}

func (self *OutgoingRequest) SetHandle(handle int32) {
	self.handle.Set(handle)
}

func (self *OutgoingRequest) Handle() int32 {
	return self.handle.Use()
}

func (self *OutgoingRequest) Drop() {
	handle := self.handle.TakeOrNil()
	if handle != 0 {
		resourceDropOutgoingRequest(handle)
	}
}

func OutgoingRequestFromOwnHandle(handleValue int32) *OutgoingRequest {
	handle := wit_runtime.MakeHandle(handleValue)
	value := &OutgoingRequest{handle}
	runtime.AddCleanup(value, func(_ int) {
		handleValue := handle.TakeOrNil()
		if handleValue != 0 {
			resourceDropOutgoingRequest(handleValue)
		}
	}, 0)
	return value
}

func OutgoingRequestFromBorrowHandle(handleValue int32) *OutgoingRequest {
	return OutgoingRequestFromOwnHandle(handleValue)
}

//go:wasmimport wasi:http/types@0.2.0 [resource-drop]request-options
func resourceDropRequestOptions(handle int32)

// Parameters for making an HTTP Request. Each of these parameters is
// currently an optional timeout applicable to the transport layer of the
// HTTP protocol.
//
// These timeouts are separate from any the user may use to bound a
// blocking call to `wasi:io/poll.poll`.
type RequestOptions struct {
	handle *wit_runtime.Handle
}

func (self *RequestOptions) TakeHandle() int32 {
	return self.handle.Take()
}

func (self *RequestOptions) SetHandle(handle int32) {
	self.handle.Set(handle)
}

func (self *RequestOptions) Handle() int32 {
	return self.handle.Use()
}

func (self *RequestOptions) Drop() {
	handle := self.handle.TakeOrNil()
	if handle != 0 {
		resourceDropRequestOptions(handle)
	}
}

func RequestOptionsFromOwnHandle(handleValue int32) *RequestOptions {
	handle := wit_runtime.MakeHandle(handleValue)
	value := &RequestOptions{handle}
	runtime.AddCleanup(value, func(_ int) {
		handleValue := handle.TakeOrNil()
		if handleValue != 0 {
			resourceDropRequestOptions(handleValue)
		}
	}, 0)
	return value
}

func RequestOptionsFromBorrowHandle(handleValue int32) *RequestOptions {
	return RequestOptionsFromOwnHandle(handleValue)
}

//go:wasmimport wasi:http/types@0.2.0 [resource-drop]response-outparam
func resourceDropResponseOutparam(handle int32)

// Represents the ability to send an HTTP Response.
//
// This resource is used by the `wasi:http/incoming-handler` interface to
// allow a Response to be sent corresponding to the Request provided as the
// other argument to `incoming-handler.handle`.
type ResponseOutparam struct {
	handle *wit_runtime.Handle
}

func (self *ResponseOutparam) TakeHandle() int32 {
	return self.handle.Take()
}

func (self *ResponseOutparam) SetHandle(handle int32) {
	self.handle.Set(handle)
}

func (self *ResponseOutparam) Handle() int32 {
	return self.handle.Use()
}

func (self *ResponseOutparam) Drop() {
	handle := self.handle.TakeOrNil()
	if handle != 0 {
		resourceDropResponseOutparam(handle)
	}
}

func ResponseOutparamFromOwnHandle(handleValue int32) *ResponseOutparam {
	handle := wit_runtime.MakeHandle(handleValue)
	value := &ResponseOutparam{handle}
	runtime.AddCleanup(value, func(_ int) {
		handleValue := handle.TakeOrNil()
		if handleValue != 0 {
			resourceDropResponseOutparam(handleValue)
		}
	}, 0)
	return value
}

func ResponseOutparamFromBorrowHandle(handleValue int32) *ResponseOutparam {
	return ResponseOutparamFromOwnHandle(handleValue)
}

// This type corresponds to the HTTP standard Status Code.
type StatusCode = uint16

//go:wasmimport wasi:http/types@0.2.0 [resource-drop]incoming-response
func resourceDropIncomingResponse(handle int32)

// Represents an incoming HTTP Response.
type IncomingResponse struct {
	handle *wit_runtime.Handle
}

func (self *IncomingResponse) TakeHandle() int32 {
	return self.handle.Take()
}

func (self *IncomingResponse) SetHandle(handle int32) {
	self.handle.Set(handle)
}

func (self *IncomingResponse) Handle() int32 {
	return self.handle.Use()
}

func (self *IncomingResponse) Drop() {
	handle := self.handle.TakeOrNil()
	if handle != 0 {
		resourceDropIncomingResponse(handle)
	}
}

func IncomingResponseFromOwnHandle(handleValue int32) *IncomingResponse {
	handle := wit_runtime.MakeHandle(handleValue)
	value := &IncomingResponse{handle}
	runtime.AddCleanup(value, func(_ int) {
		handleValue := handle.TakeOrNil()
		if handleValue != 0 {
			resourceDropIncomingResponse(handleValue)
		}
	}, 0)
	return value
}

func IncomingResponseFromBorrowHandle(handleValue int32) *IncomingResponse {
	return IncomingResponseFromOwnHandle(handleValue)
}

//go:wasmimport wasi:http/types@0.2.0 [resource-drop]incoming-body
func resourceDropIncomingBody(handle int32)

// Represents an incoming HTTP Request or Response's Body.
//
// A body has both its contents - a stream of bytes - and a (possibly
// empty) set of trailers, indicating that the full contents of the
// body have been received. This resource represents the contents as
// an `input-stream` and the delivery of trailers as a `future-trailers`,
// and ensures that the user of this interface may only be consuming either
// the body contents or waiting on trailers at any given time.
type IncomingBody struct {
	handle *wit_runtime.Handle
}

func (self *IncomingBody) TakeHandle() int32 {
	return self.handle.Take()
}

func (self *IncomingBody) SetHandle(handle int32) {
	self.handle.Set(handle)
}

func (self *IncomingBody) Handle() int32 {
	return self.handle.Use()
}

func (self *IncomingBody) Drop() {
	handle := self.handle.TakeOrNil()
	if handle != 0 {
		resourceDropIncomingBody(handle)
	}
}

func IncomingBodyFromOwnHandle(handleValue int32) *IncomingBody {
	handle := wit_runtime.MakeHandle(handleValue)
	value := &IncomingBody{handle}
	runtime.AddCleanup(value, func(_ int) {
		handleValue := handle.TakeOrNil()
		if handleValue != 0 {
			resourceDropIncomingBody(handleValue)
		}
	}, 0)
	return value
}

func IncomingBodyFromBorrowHandle(handleValue int32) *IncomingBody {
	return IncomingBodyFromOwnHandle(handleValue)
}

//go:wasmimport wasi:http/types@0.2.0 [resource-drop]future-trailers
func resourceDropFutureTrailers(handle int32)

// Represents a future which may eventaully return trailers, or an error.
//
// In the case that the incoming HTTP Request or Response did not have any
// trailers, this future will resolve to the empty set of trailers once the
// complete Request or Response body has been received.
type FutureTrailers struct {
	handle *wit_runtime.Handle
}

func (self *FutureTrailers) TakeHandle() int32 {
	return self.handle.Take()
}

func (self *FutureTrailers) SetHandle(handle int32) {
	self.handle.Set(handle)
}

func (self *FutureTrailers) Handle() int32 {
	return self.handle.Use()
}

func (self *FutureTrailers) Drop() {
	handle := self.handle.TakeOrNil()
	if handle != 0 {
		resourceDropFutureTrailers(handle)
	}
}

func FutureTrailersFromOwnHandle(handleValue int32) *FutureTrailers {
	handle := wit_runtime.MakeHandle(handleValue)
	value := &FutureTrailers{handle}
	runtime.AddCleanup(value, func(_ int) {
		handleValue := handle.TakeOrNil()
		if handleValue != 0 {
			resourceDropFutureTrailers(handleValue)
		}
	}, 0)
	return value
}

func FutureTrailersFromBorrowHandle(handleValue int32) *FutureTrailers {
	return FutureTrailersFromOwnHandle(handleValue)
}

//go:wasmimport wasi:http/types@0.2.0 [resource-drop]outgoing-response
func resourceDropOutgoingResponse(handle int32)

// Represents an outgoing HTTP Response.
type OutgoingResponse struct {
	handle *wit_runtime.Handle
}

func (self *OutgoingResponse) TakeHandle() int32 {
	return self.handle.Take()
}

func (self *OutgoingResponse) SetHandle(handle int32) {
	self.handle.Set(handle)
}

func (self *OutgoingResponse) Handle() int32 {
	return self.handle.Use()
}

func (self *OutgoingResponse) Drop() {
	handle := self.handle.TakeOrNil()
	if handle != 0 {
		resourceDropOutgoingResponse(handle)
	}
}

func OutgoingResponseFromOwnHandle(handleValue int32) *OutgoingResponse {
	handle := wit_runtime.MakeHandle(handleValue)
	value := &OutgoingResponse{handle}
	runtime.AddCleanup(value, func(_ int) {
		handleValue := handle.TakeOrNil()
		if handleValue != 0 {
			resourceDropOutgoingResponse(handleValue)
		}
	}, 0)
	return value
}

func OutgoingResponseFromBorrowHandle(handleValue int32) *OutgoingResponse {
	return OutgoingResponseFromOwnHandle(handleValue)
}

//go:wasmimport wasi:http/types@0.2.0 [resource-drop]outgoing-body
func resourceDropOutgoingBody(handle int32)

// Represents an outgoing HTTP Request or Response's Body.
//
// A body has both its contents - a stream of bytes - and a (possibly
// empty) set of trailers, inducating the full contents of the body
// have been sent. This resource represents the contents as an
// `output-stream` child resource, and the completion of the body (with
// optional trailers) with a static function that consumes the
// `outgoing-body` resource, and ensures that the user of this interface
// may not write to the body contents after the body has been finished.
//
// If the user code drops this resource, as opposed to calling the static
// method `finish`, the implementation should treat the body as incomplete,
// and that an error has occured. The implementation should propogate this
// error to the HTTP protocol by whatever means it has available,
// including: corrupting the body on the wire, aborting the associated
// Request, or sending a late status code for the Response.
type OutgoingBody struct {
	handle *wit_runtime.Handle
}

func (self *OutgoingBody) TakeHandle() int32 {
	return self.handle.Take()
}

func (self *OutgoingBody) SetHandle(handle int32) {
	self.handle.Set(handle)
}

func (self *OutgoingBody) Handle() int32 {
	return self.handle.Use()
}

func (self *OutgoingBody) Drop() {
	handle := self.handle.TakeOrNil()
	if handle != 0 {
		resourceDropOutgoingBody(handle)
	}
}

func OutgoingBodyFromOwnHandle(handleValue int32) *OutgoingBody {
	handle := wit_runtime.MakeHandle(handleValue)
	value := &OutgoingBody{handle}
	runtime.AddCleanup(value, func(_ int) {
		handleValue := handle.TakeOrNil()
		if handleValue != 0 {
			resourceDropOutgoingBody(handleValue)
		}
	}, 0)
	return value
}

func OutgoingBodyFromBorrowHandle(handleValue int32) *OutgoingBody {
	return OutgoingBodyFromOwnHandle(handleValue)
}

//go:wasmimport wasi:http/types@0.2.0 [resource-drop]future-incoming-response
func resourceDropFutureIncomingResponse(handle int32)

// Represents a future which may eventaully return an incoming HTTP
// Response, or an error.
//
// This resource is returned by the `wasi:http/outgoing-handler` interface to
// provide the HTTP Response corresponding to the sent Request.
type FutureIncomingResponse struct {
	handle *wit_runtime.Handle
}

func (self *FutureIncomingResponse) TakeHandle() int32 {
	return self.handle.Take()
}

func (self *FutureIncomingResponse) SetHandle(handle int32) {
	self.handle.Set(handle)
}

func (self *FutureIncomingResponse) Handle() int32 {
	return self.handle.Use()
}

func (self *FutureIncomingResponse) Drop() {
	handle := self.handle.TakeOrNil()
	if handle != 0 {
		resourceDropFutureIncomingResponse(handle)
	}
}

func FutureIncomingResponseFromOwnHandle(handleValue int32) *FutureIncomingResponse {
	handle := wit_runtime.MakeHandle(handleValue)
	value := &FutureIncomingResponse{handle}
	runtime.AddCleanup(value, func(_ int) {
		handleValue := handle.TakeOrNil()
		if handleValue != 0 {
			resourceDropFutureIncomingResponse(handleValue)
		}
	}, 0)
	return value
}

func FutureIncomingResponseFromBorrowHandle(handleValue int32) *FutureIncomingResponse {
	return FutureIncomingResponseFromOwnHandle(handleValue)
}

//go:wasmimport wasi:http/types@0.2.0 [constructor]fields
func wasm_import_constructor_fields() int32

func MakeFields() *Fields {

	result := wasm_import_constructor_fields()
	return FieldsFromOwnHandle(int32(uintptr(result)))

}

//go:wasmimport wasi:http/types@0.2.0 [static]fields.from-list
func wasm_import_static_fields_from_list(arg0 uintptr, arg1 uint32, arg2 uintptr)

func FieldsFromList(entries []wit_types.Tuple2[string, []uint8]) wit_types.Result[*Fields, HeaderError] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, 8, 4))
	slice := entries
	length := uint32(len(slice))
	result := wit_runtime.Allocate(pinner, uintptr(length*(4*4)), 4)
	for index, element := range slice {
		base := unsafe.Add(result, index*(4*4))
		utf8 := unsafe.Pointer(unsafe.StringData((element).F0))
		pinner.Pin(utf8)
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).F0)))
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf8)))
		data := unsafe.Pointer(unsafe.SliceData((element).F1))
		pinner.Pin(data)
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).F1)))
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(data)))

	}

	wasm_import_static_fields_from_list(uintptr(result), length, returnArea)
	var result0 wit_types.Result[*Fields, HeaderError]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		result0 = wit_types.Ok[*Fields, HeaderError](FieldsFromOwnHandle(int32(uintptr(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 4))))))
	case 1:
		var variant HeaderError
		switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 4))) {
		case 0:

			variant = MakeHeaderErrorInvalidSyntax()

		case 1:

			variant = MakeHeaderErrorForbidden()

		case 2:

			variant = MakeHeaderErrorImmutable()

		default:
			panic("unreachable")
		}

		result0 = wit_types.Err[*Fields, HeaderError](variant)
	default:
		panic("unreachable")
	}
	result1 := result0
	return result1

}

//go:wasmimport wasi:http/types@0.2.0 [method]fields.get
func wasm_import_method_fields_get(arg0 int32, arg1 uintptr, arg2 uint32, arg3 uintptr)

func (self *Fields) Get(name string) [][]uint8 {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, (2 * 4), 4))
	utf8 := unsafe.Pointer(unsafe.StringData(name))
	pinner.Pin(utf8)
	wasm_import_method_fields_get((self).Handle(), uintptr(utf8), uint32(len(name)), returnArea)
	result := make([][]uint8, 0, *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 4)))
	for index := 0; index < int(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 4))); index++ {
		base := unsafe.Add(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0)))), index*(2*4))
		value := unsafe.Slice((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0))))), *(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)))

		result = append(result, value)
	}

	result0 := result
	return result0

}

//go:wasmimport wasi:http/types@0.2.0 [method]fields.has
func wasm_import_method_fields_has(arg0 int32, arg1 uintptr, arg2 uint32) int32

func (self *Fields) Has(name string) bool {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	utf8 := unsafe.Pointer(unsafe.StringData(name))
	pinner.Pin(utf8)
	result := wasm_import_method_fields_has((self).Handle(), uintptr(utf8), uint32(len(name)))
	return (result != 0)

}

//go:wasmimport wasi:http/types@0.2.0 [method]fields.set
func wasm_import_method_fields_set(arg0 int32, arg1 uintptr, arg2 uint32, arg3 uintptr, arg4 uint32, arg5 uintptr)

func (self *Fields) Set(name string, value [][]uint8) wit_types.Result[wit_types.Unit, HeaderError] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, 2, 1))
	utf8 := unsafe.Pointer(unsafe.StringData(name))
	pinner.Pin(utf8)
	slice := value
	length := uint32(len(slice))
	result := wit_runtime.Allocate(pinner, uintptr(length*(2*4)), 4)
	for index, element := range slice {
		base := unsafe.Add(result, index*(2*4))
		data := unsafe.Pointer(unsafe.SliceData(element))
		pinner.Pin(data)
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len(element)))
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(data)))

	}

	wasm_import_method_fields_set((self).Handle(), uintptr(utf8), uint32(len(name)), uintptr(result), length, returnArea)
	var result0 wit_types.Result[wit_types.Unit, HeaderError]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		result0 = wit_types.Ok[wit_types.Unit, HeaderError](wit_types.Unit{})
	case 1:
		var variant HeaderError
		switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 1))) {
		case 0:

			variant = MakeHeaderErrorInvalidSyntax()

		case 1:

			variant = MakeHeaderErrorForbidden()

		case 2:

			variant = MakeHeaderErrorImmutable()

		default:
			panic("unreachable")
		}

		result0 = wit_types.Err[wit_types.Unit, HeaderError](variant)
	default:
		panic("unreachable")
	}
	result1 := result0
	return result1

}

//go:wasmimport wasi:http/types@0.2.0 [method]fields.delete
func wasm_import_method_fields_delete(arg0 int32, arg1 uintptr, arg2 uint32, arg3 uintptr)

func (self *Fields) Delete(name string) wit_types.Result[wit_types.Unit, HeaderError] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, 2, 1))
	utf8 := unsafe.Pointer(unsafe.StringData(name))
	pinner.Pin(utf8)
	wasm_import_method_fields_delete((self).Handle(), uintptr(utf8), uint32(len(name)), returnArea)
	var result wit_types.Result[wit_types.Unit, HeaderError]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		result = wit_types.Ok[wit_types.Unit, HeaderError](wit_types.Unit{})
	case 1:
		var variant HeaderError
		switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 1))) {
		case 0:

			variant = MakeHeaderErrorInvalidSyntax()

		case 1:

			variant = MakeHeaderErrorForbidden()

		case 2:

			variant = MakeHeaderErrorImmutable()

		default:
			panic("unreachable")
		}

		result = wit_types.Err[wit_types.Unit, HeaderError](variant)
	default:
		panic("unreachable")
	}
	result0 := result
	return result0

}

//go:wasmimport wasi:http/types@0.2.0 [method]fields.append
func wasm_import_method_fields_append(arg0 int32, arg1 uintptr, arg2 uint32, arg3 uintptr, arg4 uint32, arg5 uintptr)

func (self *Fields) Append(name string, value []uint8) wit_types.Result[wit_types.Unit, HeaderError] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, 2, 1))
	utf8 := unsafe.Pointer(unsafe.StringData(name))
	pinner.Pin(utf8)
	data := unsafe.Pointer(unsafe.SliceData(value))
	pinner.Pin(data)
	wasm_import_method_fields_append((self).Handle(), uintptr(utf8), uint32(len(name)), uintptr(data), uint32(len(value)), returnArea)
	var result wit_types.Result[wit_types.Unit, HeaderError]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		result = wit_types.Ok[wit_types.Unit, HeaderError](wit_types.Unit{})
	case 1:
		var variant HeaderError
		switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 1))) {
		case 0:

			variant = MakeHeaderErrorInvalidSyntax()

		case 1:

			variant = MakeHeaderErrorForbidden()

		case 2:

			variant = MakeHeaderErrorImmutable()

		default:
			panic("unreachable")
		}

		result = wit_types.Err[wit_types.Unit, HeaderError](variant)
	default:
		panic("unreachable")
	}
	result0 := result
	return result0

}

//go:wasmimport wasi:http/types@0.2.0 [method]fields.entries
func wasm_import_method_fields_entries(arg0 int32, arg1 uintptr)

func (self *Fields) Entries() []wit_types.Tuple2[string, []uint8] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, (2 * 4), 4))
	wasm_import_method_fields_entries((self).Handle(), returnArea)
	result := make([]wit_types.Tuple2[string, []uint8], 0, *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 4)))
	for index := 0; index < int(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 4))); index++ {
		base := unsafe.Add(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0)))), index*(4*4))
		value := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0))))), *(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)))
		value0 := unsafe.Slice((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))))

		result = append(result, wit_types.Tuple2[string, []uint8]{value, value0})
	}

	result1 := result
	return result1

}

//go:wasmimport wasi:http/types@0.2.0 [method]fields.clone
func wasm_import_method_fields_clone(arg0 int32) int32

func (self *Fields) Clone() *Fields {

	result := wasm_import_method_fields_clone((self).Handle())
	return FieldsFromOwnHandle(int32(uintptr(result)))

}

//go:wasmimport wasi:http/types@0.2.0 [method]incoming-request.method
func wasm_import_method_incoming_request_method(arg0 int32, arg1 uintptr)

func (self *IncomingRequest) Method() Method {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, (3 * 4), 4))
	wasm_import_method_incoming_request_method((self).Handle(), returnArea)
	var variant Method
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		variant = MakeMethodGet()

	case 1:

		variant = MakeMethodHead()

	case 2:

		variant = MakeMethodPost()

	case 3:

		variant = MakeMethodPut()

	case 4:

		variant = MakeMethodDelete()

	case 5:

		variant = MakeMethodConnect()

	case 6:

		variant = MakeMethodOptions()

	case 7:

		variant = MakeMethodTrace()

	case 8:

		variant = MakeMethodPatch()

	case 9:
		value := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 4))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (2 * 4))))

		variant = MakeMethodOther(value)

	default:
		panic("unreachable")
	}
	result := variant
	return result

}

//go:wasmimport wasi:http/types@0.2.0 [method]incoming-request.path-with-query
func wasm_import_method_incoming_request_path_with_query(arg0 int32, arg1 uintptr)

func (self *IncomingRequest) PathWithQuery() wit_types.Option[string] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, (3 * 4), 4))
	wasm_import_method_incoming_request_path_with_query((self).Handle(), returnArea)
	var option wit_types.Option[string]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		option = wit_types.None[string]()
	case 1:
		value := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 4))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (2 * 4))))

		option = wit_types.Some[string](value)
	default:
		panic("unreachable")
	}
	result := option
	return result

}

//go:wasmimport wasi:http/types@0.2.0 [method]incoming-request.scheme
func wasm_import_method_incoming_request_scheme(arg0 int32, arg1 uintptr)

func (self *IncomingRequest) Scheme() wit_types.Option[Scheme] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, (4 * 4), 4))
	wasm_import_method_incoming_request_scheme((self).Handle(), returnArea)
	var option wit_types.Option[Scheme]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		option = wit_types.None[Scheme]()
	case 1:
		var variant Scheme
		switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 4))) {
		case 0:

			variant = MakeSchemeHttp()

		case 1:

			variant = MakeSchemeHttps()

		case 2:
			value := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (2 * 4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (3 * 4))))

			variant = MakeSchemeOther(value)

		default:
			panic("unreachable")
		}

		option = wit_types.Some[Scheme](variant)
	default:
		panic("unreachable")
	}
	result := option
	return result

}

//go:wasmimport wasi:http/types@0.2.0 [method]incoming-request.authority
func wasm_import_method_incoming_request_authority(arg0 int32, arg1 uintptr)

func (self *IncomingRequest) Authority() wit_types.Option[string] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, (3 * 4), 4))
	wasm_import_method_incoming_request_authority((self).Handle(), returnArea)
	var option wit_types.Option[string]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		option = wit_types.None[string]()
	case 1:
		value := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 4))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (2 * 4))))

		option = wit_types.Some[string](value)
	default:
		panic("unreachable")
	}
	result := option
	return result

}

//go:wasmimport wasi:http/types@0.2.0 [method]incoming-request.headers
func wasm_import_method_incoming_request_headers(arg0 int32) int32

func (self *IncomingRequest) Headers() *Fields {

	result := wasm_import_method_incoming_request_headers((self).Handle())
	return FieldsFromOwnHandle(int32(uintptr(result)))

}

//go:wasmimport wasi:http/types@0.2.0 [method]incoming-request.consume
func wasm_import_method_incoming_request_consume(arg0 int32, arg1 uintptr)

func (self *IncomingRequest) Consume() wit_types.Result[*IncomingBody, wit_types.Unit] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, 8, 4))
	wasm_import_method_incoming_request_consume((self).Handle(), returnArea)
	var result wit_types.Result[*IncomingBody, wit_types.Unit]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		result = wit_types.Ok[*IncomingBody, wit_types.Unit](IncomingBodyFromOwnHandle(int32(uintptr(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 4))))))
	case 1:

		result = wit_types.Err[*IncomingBody, wit_types.Unit](wit_types.Unit{})
	default:
		panic("unreachable")
	}
	result0 := result
	return result0

}

//go:wasmimport wasi:http/types@0.2.0 [constructor]outgoing-request
func wasm_import_constructor_outgoing_request(arg0 int32) int32

func MakeOutgoingRequest(headers *Fields) *OutgoingRequest {

	result := wasm_import_constructor_outgoing_request((headers).TakeHandle())
	return OutgoingRequestFromOwnHandle(int32(uintptr(result)))

}

//go:wasmimport wasi:http/types@0.2.0 [method]outgoing-request.body
func wasm_import_method_outgoing_request_body(arg0 int32, arg1 uintptr)

func (self *OutgoingRequest) Body() wit_types.Result[*OutgoingBody, wit_types.Unit] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, 8, 4))
	wasm_import_method_outgoing_request_body((self).Handle(), returnArea)
	var result wit_types.Result[*OutgoingBody, wit_types.Unit]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		result = wit_types.Ok[*OutgoingBody, wit_types.Unit](OutgoingBodyFromOwnHandle(int32(uintptr(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 4))))))
	case 1:

		result = wit_types.Err[*OutgoingBody, wit_types.Unit](wit_types.Unit{})
	default:
		panic("unreachable")
	}
	result0 := result
	return result0

}

//go:wasmimport wasi:http/types@0.2.0 [method]outgoing-request.method
func wasm_import_method_outgoing_request_method(arg0 int32, arg1 uintptr)

func (self *OutgoingRequest) Method() Method {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, (3 * 4), 4))
	wasm_import_method_outgoing_request_method((self).Handle(), returnArea)
	var variant Method
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		variant = MakeMethodGet()

	case 1:

		variant = MakeMethodHead()

	case 2:

		variant = MakeMethodPost()

	case 3:

		variant = MakeMethodPut()

	case 4:

		variant = MakeMethodDelete()

	case 5:

		variant = MakeMethodConnect()

	case 6:

		variant = MakeMethodOptions()

	case 7:

		variant = MakeMethodTrace()

	case 8:

		variant = MakeMethodPatch()

	case 9:
		value := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 4))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (2 * 4))))

		variant = MakeMethodOther(value)

	default:
		panic("unreachable")
	}
	result := variant
	return result

}

//go:wasmimport wasi:http/types@0.2.0 [method]outgoing-request.set-method
func wasm_import_method_outgoing_request_set_method(arg0 int32, arg1 int32, arg2 uintptr, arg3 uint32) int32

func (self *OutgoingRequest) SetMethod(method Method) wit_types.Result[wit_types.Unit, wit_types.Unit] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	var variant int32
	var variant0 uintptr
	var variant1 uint32
	switch method.Tag() {
	case MethodGet:

		variant = int32(0)
		variant0 = 0
		variant1 = 0

	case MethodHead:

		variant = int32(1)
		variant0 = 0
		variant1 = 0

	case MethodPost:

		variant = int32(2)
		variant0 = 0
		variant1 = 0

	case MethodPut:

		variant = int32(3)
		variant0 = 0
		variant1 = 0

	case MethodDelete:

		variant = int32(4)
		variant0 = 0
		variant1 = 0

	case MethodConnect:

		variant = int32(5)
		variant0 = 0
		variant1 = 0

	case MethodOptions:

		variant = int32(6)
		variant0 = 0
		variant1 = 0

	case MethodTrace:

		variant = int32(7)
		variant0 = 0
		variant1 = 0

	case MethodPatch:

		variant = int32(8)
		variant0 = 0
		variant1 = 0

	case MethodOther:
		payload := method.Other()
		utf8 := unsafe.Pointer(unsafe.StringData(payload))
		pinner.Pin(utf8)

		variant = int32(9)
		variant0 = uintptr(utf8)
		variant1 = uint32(len(payload))

	default:
		panic("unreachable")
	}
	result := wasm_import_method_outgoing_request_set_method((self).Handle(), variant, variant0, variant1)
	var result2 wit_types.Result[wit_types.Unit, wit_types.Unit]
	switch result {
	case 0:

		result2 = wit_types.Ok[wit_types.Unit, wit_types.Unit](wit_types.Unit{})
	case 1:

		result2 = wit_types.Err[wit_types.Unit, wit_types.Unit](wit_types.Unit{})
	default:
		panic("unreachable")
	}
	return result2

}

//go:wasmimport wasi:http/types@0.2.0 [method]outgoing-request.path-with-query
func wasm_import_method_outgoing_request_path_with_query(arg0 int32, arg1 uintptr)

func (self *OutgoingRequest) PathWithQuery() wit_types.Option[string] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, (3 * 4), 4))
	wasm_import_method_outgoing_request_path_with_query((self).Handle(), returnArea)
	var option wit_types.Option[string]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		option = wit_types.None[string]()
	case 1:
		value := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 4))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (2 * 4))))

		option = wit_types.Some[string](value)
	default:
		panic("unreachable")
	}
	result := option
	return result

}

//go:wasmimport wasi:http/types@0.2.0 [method]outgoing-request.set-path-with-query
func wasm_import_method_outgoing_request_set_path_with_query(arg0 int32, arg1 int32, arg2 uintptr, arg3 uint32) int32

func (self *OutgoingRequest) SetPathWithQuery(pathWithQuery wit_types.Option[string]) wit_types.Result[wit_types.Unit, wit_types.Unit] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	var option int32
	var option0 uintptr
	var option1 uint32
	switch pathWithQuery.Tag() {
	case wit_types.OptionNone:

		option = int32(0)
		option0 = 0
		option1 = 0
	case wit_types.OptionSome:
		payload := pathWithQuery.Some()
		utf8 := unsafe.Pointer(unsafe.StringData(payload))
		pinner.Pin(utf8)

		option = int32(1)
		option0 = uintptr(utf8)
		option1 = uint32(len(payload))
	default:
		panic("unreachable")
	}
	result := wasm_import_method_outgoing_request_set_path_with_query((self).Handle(), option, option0, option1)
	var result2 wit_types.Result[wit_types.Unit, wit_types.Unit]
	switch result {
	case 0:

		result2 = wit_types.Ok[wit_types.Unit, wit_types.Unit](wit_types.Unit{})
	case 1:

		result2 = wit_types.Err[wit_types.Unit, wit_types.Unit](wit_types.Unit{})
	default:
		panic("unreachable")
	}
	return result2

}

//go:wasmimport wasi:http/types@0.2.0 [method]outgoing-request.scheme
func wasm_import_method_outgoing_request_scheme(arg0 int32, arg1 uintptr)

func (self *OutgoingRequest) Scheme() wit_types.Option[Scheme] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, (4 * 4), 4))
	wasm_import_method_outgoing_request_scheme((self).Handle(), returnArea)
	var option wit_types.Option[Scheme]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		option = wit_types.None[Scheme]()
	case 1:
		var variant Scheme
		switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 4))) {
		case 0:

			variant = MakeSchemeHttp()

		case 1:

			variant = MakeSchemeHttps()

		case 2:
			value := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (2 * 4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (3 * 4))))

			variant = MakeSchemeOther(value)

		default:
			panic("unreachable")
		}

		option = wit_types.Some[Scheme](variant)
	default:
		panic("unreachable")
	}
	result := option
	return result

}

//go:wasmimport wasi:http/types@0.2.0 [method]outgoing-request.set-scheme
func wasm_import_method_outgoing_request_set_scheme(arg0 int32, arg1 int32, arg2 int32, arg3 uintptr, arg4 uint32) int32

func (self *OutgoingRequest) SetScheme(scheme wit_types.Option[Scheme]) wit_types.Result[wit_types.Unit, wit_types.Unit] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	var option int32
	var option2 int32
	var option3 uintptr
	var option4 uint32
	switch scheme.Tag() {
	case wit_types.OptionNone:

		option = int32(0)
		option2 = 0
		option3 = 0
		option4 = 0
	case wit_types.OptionSome:
		payload := scheme.Some()
		var variant int32
		var variant0 uintptr
		var variant1 uint32
		switch payload.Tag() {
		case SchemeHttp:

			variant = int32(0)
			variant0 = 0
			variant1 = 0

		case SchemeHttps:

			variant = int32(1)
			variant0 = 0
			variant1 = 0

		case SchemeOther:
			payload := payload.Other()
			utf8 := unsafe.Pointer(unsafe.StringData(payload))
			pinner.Pin(utf8)

			variant = int32(2)
			variant0 = uintptr(utf8)
			variant1 = uint32(len(payload))

		default:
			panic("unreachable")
		}

		option = int32(1)
		option2 = variant
		option3 = variant0
		option4 = variant1
	default:
		panic("unreachable")
	}
	result := wasm_import_method_outgoing_request_set_scheme((self).Handle(), option, option2, option3, option4)
	var result5 wit_types.Result[wit_types.Unit, wit_types.Unit]
	switch result {
	case 0:

		result5 = wit_types.Ok[wit_types.Unit, wit_types.Unit](wit_types.Unit{})
	case 1:

		result5 = wit_types.Err[wit_types.Unit, wit_types.Unit](wit_types.Unit{})
	default:
		panic("unreachable")
	}
	return result5

}

//go:wasmimport wasi:http/types@0.2.0 [method]outgoing-request.authority
func wasm_import_method_outgoing_request_authority(arg0 int32, arg1 uintptr)

func (self *OutgoingRequest) Authority() wit_types.Option[string] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, (3 * 4), 4))
	wasm_import_method_outgoing_request_authority((self).Handle(), returnArea)
	var option wit_types.Option[string]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		option = wit_types.None[string]()
	case 1:
		value := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 4))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (2 * 4))))

		option = wit_types.Some[string](value)
	default:
		panic("unreachable")
	}
	result := option
	return result

}

//go:wasmimport wasi:http/types@0.2.0 [method]outgoing-request.set-authority
func wasm_import_method_outgoing_request_set_authority(arg0 int32, arg1 int32, arg2 uintptr, arg3 uint32) int32

func (self *OutgoingRequest) SetAuthority(authority wit_types.Option[string]) wit_types.Result[wit_types.Unit, wit_types.Unit] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	var option int32
	var option0 uintptr
	var option1 uint32
	switch authority.Tag() {
	case wit_types.OptionNone:

		option = int32(0)
		option0 = 0
		option1 = 0
	case wit_types.OptionSome:
		payload := authority.Some()
		utf8 := unsafe.Pointer(unsafe.StringData(payload))
		pinner.Pin(utf8)

		option = int32(1)
		option0 = uintptr(utf8)
		option1 = uint32(len(payload))
	default:
		panic("unreachable")
	}
	result := wasm_import_method_outgoing_request_set_authority((self).Handle(), option, option0, option1)
	var result2 wit_types.Result[wit_types.Unit, wit_types.Unit]
	switch result {
	case 0:

		result2 = wit_types.Ok[wit_types.Unit, wit_types.Unit](wit_types.Unit{})
	case 1:

		result2 = wit_types.Err[wit_types.Unit, wit_types.Unit](wit_types.Unit{})
	default:
		panic("unreachable")
	}
	return result2

}

//go:wasmimport wasi:http/types@0.2.0 [method]outgoing-request.headers
func wasm_import_method_outgoing_request_headers(arg0 int32) int32

func (self *OutgoingRequest) Headers() *Fields {

	result := wasm_import_method_outgoing_request_headers((self).Handle())
	return FieldsFromOwnHandle(int32(uintptr(result)))

}

//go:wasmimport wasi:http/types@0.2.0 [constructor]request-options
func wasm_import_constructor_request_options() int32

func MakeRequestOptions() *RequestOptions {

	result := wasm_import_constructor_request_options()
	return RequestOptionsFromOwnHandle(int32(uintptr(result)))

}

//go:wasmimport wasi:http/types@0.2.0 [method]request-options.connect-timeout
func wasm_import_method_request_options_connect_timeout(arg0 int32, arg1 uintptr)

func (self *RequestOptions) ConnectTimeout() wit_types.Option[uint64] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, 16, 8))
	wasm_import_method_request_options_connect_timeout((self).Handle(), returnArea)
	var option wit_types.Option[uint64]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		option = wit_types.None[uint64]()
	case 1:

		option = wit_types.Some[uint64](uint64(*(*int64)(unsafe.Add(unsafe.Pointer(returnArea), 8))))
	default:
		panic("unreachable")
	}
	result := option
	return result

}

//go:wasmimport wasi:http/types@0.2.0 [method]request-options.set-connect-timeout
func wasm_import_method_request_options_set_connect_timeout(arg0 int32, arg1 int32, arg2 int64) int32

func (self *RequestOptions) SetConnectTimeout(duration wit_types.Option[uint64]) wit_types.Result[wit_types.Unit, wit_types.Unit] {

	var option int32
	var option0 int64
	switch duration.Tag() {
	case wit_types.OptionNone:

		option = int32(0)
		option0 = 0
	case wit_types.OptionSome:
		payload := duration.Some()

		option = int32(1)
		option0 = int64(payload)
	default:
		panic("unreachable")
	}
	result := wasm_import_method_request_options_set_connect_timeout((self).Handle(), option, option0)
	var result1 wit_types.Result[wit_types.Unit, wit_types.Unit]
	switch result {
	case 0:

		result1 = wit_types.Ok[wit_types.Unit, wit_types.Unit](wit_types.Unit{})
	case 1:

		result1 = wit_types.Err[wit_types.Unit, wit_types.Unit](wit_types.Unit{})
	default:
		panic("unreachable")
	}
	return result1

}

//go:wasmimport wasi:http/types@0.2.0 [method]request-options.first-byte-timeout
func wasm_import_method_request_options_first_byte_timeout(arg0 int32, arg1 uintptr)

func (self *RequestOptions) FirstByteTimeout() wit_types.Option[uint64] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, 16, 8))
	wasm_import_method_request_options_first_byte_timeout((self).Handle(), returnArea)
	var option wit_types.Option[uint64]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		option = wit_types.None[uint64]()
	case 1:

		option = wit_types.Some[uint64](uint64(*(*int64)(unsafe.Add(unsafe.Pointer(returnArea), 8))))
	default:
		panic("unreachable")
	}
	result := option
	return result

}

//go:wasmimport wasi:http/types@0.2.0 [method]request-options.set-first-byte-timeout
func wasm_import_method_request_options_set_first_byte_timeout(arg0 int32, arg1 int32, arg2 int64) int32

func (self *RequestOptions) SetFirstByteTimeout(duration wit_types.Option[uint64]) wit_types.Result[wit_types.Unit, wit_types.Unit] {

	var option int32
	var option0 int64
	switch duration.Tag() {
	case wit_types.OptionNone:

		option = int32(0)
		option0 = 0
	case wit_types.OptionSome:
		payload := duration.Some()

		option = int32(1)
		option0 = int64(payload)
	default:
		panic("unreachable")
	}
	result := wasm_import_method_request_options_set_first_byte_timeout((self).Handle(), option, option0)
	var result1 wit_types.Result[wit_types.Unit, wit_types.Unit]
	switch result {
	case 0:

		result1 = wit_types.Ok[wit_types.Unit, wit_types.Unit](wit_types.Unit{})
	case 1:

		result1 = wit_types.Err[wit_types.Unit, wit_types.Unit](wit_types.Unit{})
	default:
		panic("unreachable")
	}
	return result1

}

//go:wasmimport wasi:http/types@0.2.0 [method]request-options.between-bytes-timeout
func wasm_import_method_request_options_between_bytes_timeout(arg0 int32, arg1 uintptr)

func (self *RequestOptions) BetweenBytesTimeout() wit_types.Option[uint64] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, 16, 8))
	wasm_import_method_request_options_between_bytes_timeout((self).Handle(), returnArea)
	var option wit_types.Option[uint64]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		option = wit_types.None[uint64]()
	case 1:

		option = wit_types.Some[uint64](uint64(*(*int64)(unsafe.Add(unsafe.Pointer(returnArea), 8))))
	default:
		panic("unreachable")
	}
	result := option
	return result

}

//go:wasmimport wasi:http/types@0.2.0 [method]request-options.set-between-bytes-timeout
func wasm_import_method_request_options_set_between_bytes_timeout(arg0 int32, arg1 int32, arg2 int64) int32

func (self *RequestOptions) SetBetweenBytesTimeout(duration wit_types.Option[uint64]) wit_types.Result[wit_types.Unit, wit_types.Unit] {

	var option int32
	var option0 int64
	switch duration.Tag() {
	case wit_types.OptionNone:

		option = int32(0)
		option0 = 0
	case wit_types.OptionSome:
		payload := duration.Some()

		option = int32(1)
		option0 = int64(payload)
	default:
		panic("unreachable")
	}
	result := wasm_import_method_request_options_set_between_bytes_timeout((self).Handle(), option, option0)
	var result1 wit_types.Result[wit_types.Unit, wit_types.Unit]
	switch result {
	case 0:

		result1 = wit_types.Ok[wit_types.Unit, wit_types.Unit](wit_types.Unit{})
	case 1:

		result1 = wit_types.Err[wit_types.Unit, wit_types.Unit](wit_types.Unit{})
	default:
		panic("unreachable")
	}
	return result1

}

//go:wasmimport wasi:http/types@0.2.0 [static]response-outparam.set
func wasm_import_static_response_outparam_set(arg0 int32, arg1 int32, arg2 int32, arg3 int32, arg4 int64, arg5 uintptr, arg6 uintptr, arg7 uint32, arg8 int32)

func ResponseOutparamSet(param *ResponseOutparam, response wit_types.Result[*OutgoingResponse, ErrorCode]) {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	var option70 int32
	var option71 int32
	var option72 int32
	var option73 int64
	var option74 uintptr
	var option75 uintptr
	var option76 uint32
	var option77 int32
	switch response.Tag() {
	case wit_types.ResultOk:
		payload := response.Ok()

		option70 = int32(0)
		option71 = (payload).TakeHandle()
		option72 = 0
		option73 = 0
		option74 = 0
		option75 = 0
		option76 = 0
		option77 = 0
	case wit_types.ResultErr:
		payload := response.Err()
		var variant int32
		var variant64 int32
		var variant65 int64
		var variant66 uintptr
		var variant67 uintptr
		var variant68 uint32
		var variant69 int32
		switch payload.Tag() {
		case ErrorCodeDnsTimeout:

			variant = int32(0)
			variant64 = 0
			variant65 = 0
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeDnsError:
			payload := payload.DnsError()
			var option int32
			var option0 uintptr
			var option1 uint32
			switch (payload).Rcode.Tag() {
			case wit_types.OptionNone:

				option = int32(0)
				option0 = 0
				option1 = 0
			case wit_types.OptionSome:
				payload := (payload).Rcode.Some()
				utf8 := unsafe.Pointer(unsafe.StringData(payload))
				pinner.Pin(utf8)

				option = int32(1)
				option0 = uintptr(utf8)
				option1 = uint32(len(payload))
			default:
				panic("unreachable")
			}
			var option2 int32
			var option3 int32
			switch (payload).InfoCode.Tag() {
			case wit_types.OptionNone:

				option2 = int32(0)
				option3 = 0
			case wit_types.OptionSome:
				payload := (payload).InfoCode.Some()

				option2 = int32(1)
				option3 = int32(payload)
			default:
				panic("unreachable")
			}

			variant = int32(1)
			variant64 = option
			variant65 = int64(option0)
			variant66 = uintptr(option1)
			variant67 = uintptr(option2)
			variant68 = uint32(option3)
			variant69 = 0

		case ErrorCodeDestinationNotFound:

			variant = int32(2)
			variant64 = 0
			variant65 = 0
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeDestinationUnavailable:

			variant = int32(3)
			variant64 = 0
			variant65 = 0
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeDestinationIpProhibited:

			variant = int32(4)
			variant64 = 0
			variant65 = 0
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeDestinationIpUnroutable:

			variant = int32(5)
			variant64 = 0
			variant65 = 0
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeConnectionRefused:

			variant = int32(6)
			variant64 = 0
			variant65 = 0
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeConnectionTerminated:

			variant = int32(7)
			variant64 = 0
			variant65 = 0
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeConnectionTimeout:

			variant = int32(8)
			variant64 = 0
			variant65 = 0
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeConnectionReadTimeout:

			variant = int32(9)
			variant64 = 0
			variant65 = 0
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeConnectionWriteTimeout:

			variant = int32(10)
			variant64 = 0
			variant65 = 0
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeConnectionLimitReached:

			variant = int32(11)
			variant64 = 0
			variant65 = 0
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeTlsProtocolError:

			variant = int32(12)
			variant64 = 0
			variant65 = 0
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeTlsCertificateError:

			variant = int32(13)
			variant64 = 0
			variant65 = 0
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeTlsAlertReceived:
			payload := payload.TlsAlertReceived()
			var option4 int32
			var option5 int32
			switch (payload).AlertId.Tag() {
			case wit_types.OptionNone:

				option4 = int32(0)
				option5 = 0
			case wit_types.OptionSome:
				payload := (payload).AlertId.Some()

				option4 = int32(1)
				option5 = int32(payload)
			default:
				panic("unreachable")
			}
			var option7 int32
			var option8 uintptr
			var option9 uint32
			switch (payload).AlertMessage.Tag() {
			case wit_types.OptionNone:

				option7 = int32(0)
				option8 = 0
				option9 = 0
			case wit_types.OptionSome:
				payload := (payload).AlertMessage.Some()
				utf86 := unsafe.Pointer(unsafe.StringData(payload))
				pinner.Pin(utf86)

				option7 = int32(1)
				option8 = uintptr(utf86)
				option9 = uint32(len(payload))
			default:
				panic("unreachable")
			}

			variant = int32(14)
			variant64 = option4
			variant65 = int64(option5)
			variant66 = uintptr(option7)
			variant67 = option8
			variant68 = option9
			variant69 = 0

		case ErrorCodeHttpRequestDenied:

			variant = int32(15)
			variant64 = 0
			variant65 = 0
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeHttpRequestLengthRequired:

			variant = int32(16)
			variant64 = 0
			variant65 = 0
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeHttpRequestBodySize:
			payload := payload.HttpRequestBodySize()
			var option10 int32
			var option11 int64
			switch payload.Tag() {
			case wit_types.OptionNone:

				option10 = int32(0)
				option11 = 0
			case wit_types.OptionSome:
				payload := payload.Some()

				option10 = int32(1)
				option11 = int64(payload)
			default:
				panic("unreachable")
			}

			variant = int32(17)
			variant64 = option10
			variant65 = option11
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeHttpRequestMethodInvalid:

			variant = int32(18)
			variant64 = 0
			variant65 = 0
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeHttpRequestUriInvalid:

			variant = int32(19)
			variant64 = 0
			variant65 = 0
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeHttpRequestUriTooLong:

			variant = int32(20)
			variant64 = 0
			variant65 = 0
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeHttpRequestHeaderSectionSize:
			payload := payload.HttpRequestHeaderSectionSize()
			var option12 int32
			var option13 int32
			switch payload.Tag() {
			case wit_types.OptionNone:

				option12 = int32(0)
				option13 = 0
			case wit_types.OptionSome:
				payload := payload.Some()

				option12 = int32(1)
				option13 = int32(payload)
			default:
				panic("unreachable")
			}

			variant = int32(21)
			variant64 = option12
			variant65 = int64(option13)
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeHttpRequestHeaderSize:
			payload := payload.HttpRequestHeaderSize()
			var option20 int32
			var option21 int32
			var option22 uintptr
			var option23 uint32
			var option24 int32
			var option25 int32
			switch payload.Tag() {
			case wit_types.OptionNone:

				option20 = int32(0)
				option21 = 0
				option22 = 0
				option23 = 0
				option24 = 0
				option25 = 0
			case wit_types.OptionSome:
				payload := payload.Some()
				var option15 int32
				var option16 uintptr
				var option17 uint32
				switch (payload).FieldName.Tag() {
				case wit_types.OptionNone:

					option15 = int32(0)
					option16 = 0
					option17 = 0
				case wit_types.OptionSome:
					payload := (payload).FieldName.Some()
					utf814 := unsafe.Pointer(unsafe.StringData(payload))
					pinner.Pin(utf814)

					option15 = int32(1)
					option16 = uintptr(utf814)
					option17 = uint32(len(payload))
				default:
					panic("unreachable")
				}
				var option18 int32
				var option19 int32
				switch (payload).FieldSize.Tag() {
				case wit_types.OptionNone:

					option18 = int32(0)
					option19 = 0
				case wit_types.OptionSome:
					payload := (payload).FieldSize.Some()

					option18 = int32(1)
					option19 = int32(payload)
				default:
					panic("unreachable")
				}

				option20 = int32(1)
				option21 = option15
				option22 = option16
				option23 = option17
				option24 = option18
				option25 = option19
			default:
				panic("unreachable")
			}

			variant = int32(22)
			variant64 = option20
			variant65 = int64(option21)
			variant66 = option22
			variant67 = uintptr(option23)
			variant68 = uint32(option24)
			variant69 = option25

		case ErrorCodeHttpRequestTrailerSectionSize:
			payload := payload.HttpRequestTrailerSectionSize()
			var option26 int32
			var option27 int32
			switch payload.Tag() {
			case wit_types.OptionNone:

				option26 = int32(0)
				option27 = 0
			case wit_types.OptionSome:
				payload := payload.Some()

				option26 = int32(1)
				option27 = int32(payload)
			default:
				panic("unreachable")
			}

			variant = int32(23)
			variant64 = option26
			variant65 = int64(option27)
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeHttpRequestTrailerSize:
			payload := payload.HttpRequestTrailerSize()
			var option29 int32
			var option30 uintptr
			var option31 uint32
			switch (payload).FieldName.Tag() {
			case wit_types.OptionNone:

				option29 = int32(0)
				option30 = 0
				option31 = 0
			case wit_types.OptionSome:
				payload := (payload).FieldName.Some()
				utf828 := unsafe.Pointer(unsafe.StringData(payload))
				pinner.Pin(utf828)

				option29 = int32(1)
				option30 = uintptr(utf828)
				option31 = uint32(len(payload))
			default:
				panic("unreachable")
			}
			var option32 int32
			var option33 int32
			switch (payload).FieldSize.Tag() {
			case wit_types.OptionNone:

				option32 = int32(0)
				option33 = 0
			case wit_types.OptionSome:
				payload := (payload).FieldSize.Some()

				option32 = int32(1)
				option33 = int32(payload)
			default:
				panic("unreachable")
			}

			variant = int32(24)
			variant64 = option29
			variant65 = int64(option30)
			variant66 = uintptr(option31)
			variant67 = uintptr(option32)
			variant68 = uint32(option33)
			variant69 = 0

		case ErrorCodeHttpResponseIncomplete:

			variant = int32(25)
			variant64 = 0
			variant65 = 0
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeHttpResponseHeaderSectionSize:
			payload := payload.HttpResponseHeaderSectionSize()
			var option34 int32
			var option35 int32
			switch payload.Tag() {
			case wit_types.OptionNone:

				option34 = int32(0)
				option35 = 0
			case wit_types.OptionSome:
				payload := payload.Some()

				option34 = int32(1)
				option35 = int32(payload)
			default:
				panic("unreachable")
			}

			variant = int32(26)
			variant64 = option34
			variant65 = int64(option35)
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeHttpResponseHeaderSize:
			payload := payload.HttpResponseHeaderSize()
			var option37 int32
			var option38 uintptr
			var option39 uint32
			switch (payload).FieldName.Tag() {
			case wit_types.OptionNone:

				option37 = int32(0)
				option38 = 0
				option39 = 0
			case wit_types.OptionSome:
				payload := (payload).FieldName.Some()
				utf836 := unsafe.Pointer(unsafe.StringData(payload))
				pinner.Pin(utf836)

				option37 = int32(1)
				option38 = uintptr(utf836)
				option39 = uint32(len(payload))
			default:
				panic("unreachable")
			}
			var option40 int32
			var option41 int32
			switch (payload).FieldSize.Tag() {
			case wit_types.OptionNone:

				option40 = int32(0)
				option41 = 0
			case wit_types.OptionSome:
				payload := (payload).FieldSize.Some()

				option40 = int32(1)
				option41 = int32(payload)
			default:
				panic("unreachable")
			}

			variant = int32(27)
			variant64 = option37
			variant65 = int64(option38)
			variant66 = uintptr(option39)
			variant67 = uintptr(option40)
			variant68 = uint32(option41)
			variant69 = 0

		case ErrorCodeHttpResponseBodySize:
			payload := payload.HttpResponseBodySize()
			var option42 int32
			var option43 int64
			switch payload.Tag() {
			case wit_types.OptionNone:

				option42 = int32(0)
				option43 = 0
			case wit_types.OptionSome:
				payload := payload.Some()

				option42 = int32(1)
				option43 = int64(payload)
			default:
				panic("unreachable")
			}

			variant = int32(28)
			variant64 = option42
			variant65 = option43
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeHttpResponseTrailerSectionSize:
			payload := payload.HttpResponseTrailerSectionSize()
			var option44 int32
			var option45 int32
			switch payload.Tag() {
			case wit_types.OptionNone:

				option44 = int32(0)
				option45 = 0
			case wit_types.OptionSome:
				payload := payload.Some()

				option44 = int32(1)
				option45 = int32(payload)
			default:
				panic("unreachable")
			}

			variant = int32(29)
			variant64 = option44
			variant65 = int64(option45)
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeHttpResponseTrailerSize:
			payload := payload.HttpResponseTrailerSize()
			var option47 int32
			var option48 uintptr
			var option49 uint32
			switch (payload).FieldName.Tag() {
			case wit_types.OptionNone:

				option47 = int32(0)
				option48 = 0
				option49 = 0
			case wit_types.OptionSome:
				payload := (payload).FieldName.Some()
				utf846 := unsafe.Pointer(unsafe.StringData(payload))
				pinner.Pin(utf846)

				option47 = int32(1)
				option48 = uintptr(utf846)
				option49 = uint32(len(payload))
			default:
				panic("unreachable")
			}
			var option50 int32
			var option51 int32
			switch (payload).FieldSize.Tag() {
			case wit_types.OptionNone:

				option50 = int32(0)
				option51 = 0
			case wit_types.OptionSome:
				payload := (payload).FieldSize.Some()

				option50 = int32(1)
				option51 = int32(payload)
			default:
				panic("unreachable")
			}

			variant = int32(30)
			variant64 = option47
			variant65 = int64(option48)
			variant66 = uintptr(option49)
			variant67 = uintptr(option50)
			variant68 = uint32(option51)
			variant69 = 0

		case ErrorCodeHttpResponseTransferCoding:
			payload := payload.HttpResponseTransferCoding()
			var option53 int32
			var option54 uintptr
			var option55 uint32
			switch payload.Tag() {
			case wit_types.OptionNone:

				option53 = int32(0)
				option54 = 0
				option55 = 0
			case wit_types.OptionSome:
				payload := payload.Some()
				utf852 := unsafe.Pointer(unsafe.StringData(payload))
				pinner.Pin(utf852)

				option53 = int32(1)
				option54 = uintptr(utf852)
				option55 = uint32(len(payload))
			default:
				panic("unreachable")
			}

			variant = int32(31)
			variant64 = option53
			variant65 = int64(option54)
			variant66 = uintptr(option55)
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeHttpResponseContentCoding:
			payload := payload.HttpResponseContentCoding()
			var option57 int32
			var option58 uintptr
			var option59 uint32
			switch payload.Tag() {
			case wit_types.OptionNone:

				option57 = int32(0)
				option58 = 0
				option59 = 0
			case wit_types.OptionSome:
				payload := payload.Some()
				utf856 := unsafe.Pointer(unsafe.StringData(payload))
				pinner.Pin(utf856)

				option57 = int32(1)
				option58 = uintptr(utf856)
				option59 = uint32(len(payload))
			default:
				panic("unreachable")
			}

			variant = int32(32)
			variant64 = option57
			variant65 = int64(option58)
			variant66 = uintptr(option59)
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeHttpResponseTimeout:

			variant = int32(33)
			variant64 = 0
			variant65 = 0
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeHttpUpgradeFailed:

			variant = int32(34)
			variant64 = 0
			variant65 = 0
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeHttpProtocolError:

			variant = int32(35)
			variant64 = 0
			variant65 = 0
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeLoopDetected:

			variant = int32(36)
			variant64 = 0
			variant65 = 0
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeConfigurationError:

			variant = int32(37)
			variant64 = 0
			variant65 = 0
			variant66 = 0
			variant67 = 0
			variant68 = 0
			variant69 = 0

		case ErrorCodeInternalError:
			payload := payload.InternalError()
			var option61 int32
			var option62 uintptr
			var option63 uint32
			switch payload.Tag() {
			case wit_types.OptionNone:

				option61 = int32(0)
				option62 = 0
				option63 = 0
			case wit_types.OptionSome:
				payload := payload.Some()
				utf860 := unsafe.Pointer(unsafe.StringData(payload))
				pinner.Pin(utf860)

				option61 = int32(1)
				option62 = uintptr(utf860)
				option63 = uint32(len(payload))
			default:
				panic("unreachable")
			}

			variant = int32(38)
			variant64 = option61
			variant65 = int64(option62)
			variant66 = uintptr(option63)
			variant67 = 0
			variant68 = 0
			variant69 = 0

		default:
			panic("unreachable")
		}

		option70 = int32(1)
		option71 = variant
		option72 = variant64
		option73 = variant65
		option74 = variant66
		option75 = variant67
		option76 = variant68
		option77 = variant69
	default:
		panic("unreachable")
	}
	wasm_import_static_response_outparam_set((param).TakeHandle(), option70, option71, option72, option73, option74, option75, option76, option77)

}

//go:wasmimport wasi:http/types@0.2.0 [method]incoming-response.status
func wasm_import_method_incoming_response_status(arg0 int32) int32

func (self *IncomingResponse) Status() uint16 {

	result := wasm_import_method_incoming_response_status((self).Handle())
	return uint16(result)

}

//go:wasmimport wasi:http/types@0.2.0 [method]incoming-response.headers
func wasm_import_method_incoming_response_headers(arg0 int32) int32

func (self *IncomingResponse) Headers() *Fields {

	result := wasm_import_method_incoming_response_headers((self).Handle())
	return FieldsFromOwnHandle(int32(uintptr(result)))

}

//go:wasmimport wasi:http/types@0.2.0 [method]incoming-response.consume
func wasm_import_method_incoming_response_consume(arg0 int32, arg1 uintptr)

func (self *IncomingResponse) Consume() wit_types.Result[*IncomingBody, wit_types.Unit] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, 8, 4))
	wasm_import_method_incoming_response_consume((self).Handle(), returnArea)
	var result wit_types.Result[*IncomingBody, wit_types.Unit]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		result = wit_types.Ok[*IncomingBody, wit_types.Unit](IncomingBodyFromOwnHandle(int32(uintptr(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 4))))))
	case 1:

		result = wit_types.Err[*IncomingBody, wit_types.Unit](wit_types.Unit{})
	default:
		panic("unreachable")
	}
	result0 := result
	return result0

}

//go:wasmimport wasi:http/types@0.2.0 [method]incoming-body.stream
func wasm_import_method_incoming_body_stream(arg0 int32, arg1 uintptr)

func (self *IncomingBody) Stream() wit_types.Result[*wasi_io_streams.InputStream, wit_types.Unit] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, 8, 4))
	wasm_import_method_incoming_body_stream((self).Handle(), returnArea)
	var result wit_types.Result[*wasi_io_streams.InputStream, wit_types.Unit]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		result = wit_types.Ok[*wasi_io_streams.InputStream, wit_types.Unit](wasi_io_streams.InputStreamFromOwnHandle(int32(uintptr(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 4))))))
	case 1:

		result = wit_types.Err[*wasi_io_streams.InputStream, wit_types.Unit](wit_types.Unit{})
	default:
		panic("unreachable")
	}
	result0 := result
	return result0

}

//go:wasmimport wasi:http/types@0.2.0 [static]incoming-body.finish
func wasm_import_static_incoming_body_finish(arg0 int32) int32

func IncomingBodyFinish(this *IncomingBody) *FutureTrailers {

	result := wasm_import_static_incoming_body_finish((this).TakeHandle())
	return FutureTrailersFromOwnHandle(int32(uintptr(result)))

}

//go:wasmimport wasi:http/types@0.2.0 [method]future-trailers.subscribe
func wasm_import_method_future_trailers_subscribe(arg0 int32) int32

func (self *FutureTrailers) Subscribe() *wasi_io_poll.Pollable {

	result := wasm_import_method_future_trailers_subscribe((self).Handle())
	return wasi_io_poll.PollableFromOwnHandle(int32(uintptr(result)))

}

//go:wasmimport wasi:http/types@0.2.0 [method]future-trailers.get
func wasm_import_method_future_trailers_get(arg0 int32, arg1 uintptr)

func (self *FutureTrailers) Get() wit_types.Option[wit_types.Result[wit_types.Result[wit_types.Option[*Fields], ErrorCode], wit_types.Unit]] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, (40 + 4*4), 8))
	wasm_import_method_future_trailers_get((self).Handle(), returnArea)
	var option31 wit_types.Option[wit_types.Result[wit_types.Result[wit_types.Option[*Fields], ErrorCode], wit_types.Unit]]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		option31 = wit_types.None[wit_types.Result[wit_types.Result[wit_types.Option[*Fields], ErrorCode], wit_types.Unit]]()
	case 1:
		var result30 wit_types.Result[wit_types.Result[wit_types.Option[*Fields], ErrorCode], wit_types.Unit]
		switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 8))) {
		case 0:
			var result wit_types.Result[wit_types.Option[*Fields], ErrorCode]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:
				var option wit_types.Option[*Fields]
				switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 24))) {
				case 0:

					option = wit_types.None[*Fields]()
				case 1:

					option = wit_types.Some[*Fields](FieldsFromOwnHandle(int32(uintptr(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 28))))))
				default:
					panic("unreachable")
				}

				result = wit_types.Ok[wit_types.Option[*Fields], ErrorCode](option)
			case 1:
				var variant ErrorCode
				switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 24))) {
				case 0:

					variant = MakeErrorCodeDnsTimeout()

				case 1:
					var option0 wit_types.Option[string]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option0 = wit_types.None[string]()
					case 1:
						value := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 1*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 2*4))))

						option0 = wit_types.Some[string](value)
					default:
						panic("unreachable")
					}
					var option1 wit_types.Option[uint16]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 3*4)))) {
					case 0:

						option1 = wit_types.None[uint16]()
					case 1:

						option1 = wit_types.Some[uint16](uint16(uint16(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (34 + 3*4))))))
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeDnsError(DnsErrorPayload{option0, option1})

				case 2:

					variant = MakeErrorCodeDestinationNotFound()

				case 3:

					variant = MakeErrorCodeDestinationUnavailable()

				case 4:

					variant = MakeErrorCodeDestinationIpProhibited()

				case 5:

					variant = MakeErrorCodeDestinationIpUnroutable()

				case 6:

					variant = MakeErrorCodeConnectionRefused()

				case 7:

					variant = MakeErrorCodeConnectionTerminated()

				case 8:

					variant = MakeErrorCodeConnectionTimeout()

				case 9:

					variant = MakeErrorCodeConnectionReadTimeout()

				case 10:

					variant = MakeErrorCodeConnectionWriteTimeout()

				case 11:

					variant = MakeErrorCodeConnectionLimitReached()

				case 12:

					variant = MakeErrorCodeTlsProtocolError()

				case 13:

					variant = MakeErrorCodeTlsCertificateError()

				case 14:
					var option2 wit_types.Option[uint8]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option2 = wit_types.None[uint8]()
					case 1:

						option2 = wit_types.Some[uint8](uint8(uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 33)))))
					default:
						panic("unreachable")
					}
					var option4 wit_types.Option[string]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 1*4)))) {
					case 0:

						option4 = wit_types.None[string]()
					case 1:
						value3 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 2*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 3*4))))

						option4 = wit_types.Some[string](value3)
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeTlsAlertReceived(TlsAlertReceivedPayload{option2, option4})

				case 15:

					variant = MakeErrorCodeHttpRequestDenied()

				case 16:

					variant = MakeErrorCodeHttpRequestLengthRequired()

				case 17:
					var option5 wit_types.Option[uint64]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option5 = wit_types.None[uint64]()
					case 1:

						option5 = wit_types.Some[uint64](uint64(*(*int64)(unsafe.Add(unsafe.Pointer(returnArea), 40))))
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeHttpRequestBodySize(option5)

				case 18:

					variant = MakeErrorCodeHttpRequestMethodInvalid()

				case 19:

					variant = MakeErrorCodeHttpRequestUriInvalid()

				case 20:

					variant = MakeErrorCodeHttpRequestUriTooLong()

				case 21:
					var option6 wit_types.Option[uint32]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option6 = wit_types.None[uint32]()
					case 1:

						option6 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 36))))
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeHttpRequestHeaderSectionSize(option6)

				case 22:
					var option10 wit_types.Option[FieldSizePayload]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option10 = wit_types.None[FieldSizePayload]()
					case 1:
						var option8 wit_types.Option[string]
						switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 1*4)))) {
						case 0:

							option8 = wit_types.None[string]()
						case 1:
							value7 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 2*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 3*4))))

							option8 = wit_types.Some[string](value7)
						default:
							panic("unreachable")
						}
						var option9 wit_types.Option[uint32]
						switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 4*4)))) {
						case 0:

							option9 = wit_types.None[uint32]()
						case 1:

							option9 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), (36 + 4*4)))))
						default:
							panic("unreachable")
						}

						option10 = wit_types.Some[FieldSizePayload](FieldSizePayload{option8, option9})
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeHttpRequestHeaderSize(option10)

				case 23:
					var option11 wit_types.Option[uint32]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option11 = wit_types.None[uint32]()
					case 1:

						option11 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 36))))
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeHttpRequestTrailerSectionSize(option11)

				case 24:
					var option13 wit_types.Option[string]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option13 = wit_types.None[string]()
					case 1:
						value12 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 1*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 2*4))))

						option13 = wit_types.Some[string](value12)
					default:
						panic("unreachable")
					}
					var option14 wit_types.Option[uint32]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 3*4)))) {
					case 0:

						option14 = wit_types.None[uint32]()
					case 1:

						option14 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), (36 + 3*4)))))
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeHttpRequestTrailerSize(FieldSizePayload{option13, option14})

				case 25:

					variant = MakeErrorCodeHttpResponseIncomplete()

				case 26:
					var option15 wit_types.Option[uint32]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option15 = wit_types.None[uint32]()
					case 1:

						option15 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 36))))
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeHttpResponseHeaderSectionSize(option15)

				case 27:
					var option17 wit_types.Option[string]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option17 = wit_types.None[string]()
					case 1:
						value16 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 1*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 2*4))))

						option17 = wit_types.Some[string](value16)
					default:
						panic("unreachable")
					}
					var option18 wit_types.Option[uint32]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 3*4)))) {
					case 0:

						option18 = wit_types.None[uint32]()
					case 1:

						option18 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), (36 + 3*4)))))
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeHttpResponseHeaderSize(FieldSizePayload{option17, option18})

				case 28:
					var option19 wit_types.Option[uint64]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option19 = wit_types.None[uint64]()
					case 1:

						option19 = wit_types.Some[uint64](uint64(*(*int64)(unsafe.Add(unsafe.Pointer(returnArea), 40))))
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeHttpResponseBodySize(option19)

				case 29:
					var option20 wit_types.Option[uint32]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option20 = wit_types.None[uint32]()
					case 1:

						option20 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 36))))
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeHttpResponseTrailerSectionSize(option20)

				case 30:
					var option22 wit_types.Option[string]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option22 = wit_types.None[string]()
					case 1:
						value21 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 1*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 2*4))))

						option22 = wit_types.Some[string](value21)
					default:
						panic("unreachable")
					}
					var option23 wit_types.Option[uint32]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 3*4)))) {
					case 0:

						option23 = wit_types.None[uint32]()
					case 1:

						option23 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), (36 + 3*4)))))
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeHttpResponseTrailerSize(FieldSizePayload{option22, option23})

				case 31:
					var option25 wit_types.Option[string]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option25 = wit_types.None[string]()
					case 1:
						value24 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 1*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 2*4))))

						option25 = wit_types.Some[string](value24)
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeHttpResponseTransferCoding(option25)

				case 32:
					var option27 wit_types.Option[string]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option27 = wit_types.None[string]()
					case 1:
						value26 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 1*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 2*4))))

						option27 = wit_types.Some[string](value26)
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeHttpResponseContentCoding(option27)

				case 33:

					variant = MakeErrorCodeHttpResponseTimeout()

				case 34:

					variant = MakeErrorCodeHttpUpgradeFailed()

				case 35:

					variant = MakeErrorCodeHttpProtocolError()

				case 36:

					variant = MakeErrorCodeLoopDetected()

				case 37:

					variant = MakeErrorCodeConfigurationError()

				case 38:
					var option29 wit_types.Option[string]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option29 = wit_types.None[string]()
					case 1:
						value28 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 1*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 2*4))))

						option29 = wit_types.Some[string](value28)
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeInternalError(option29)

				default:
					panic("unreachable")
				}

				result = wit_types.Err[wit_types.Option[*Fields], ErrorCode](variant)
			default:
				panic("unreachable")
			}

			result30 = wit_types.Ok[wit_types.Result[wit_types.Option[*Fields], ErrorCode], wit_types.Unit](result)
		case 1:

			result30 = wit_types.Err[wit_types.Result[wit_types.Option[*Fields], ErrorCode], wit_types.Unit](wit_types.Unit{})
		default:
			panic("unreachable")
		}

		option31 = wit_types.Some[wit_types.Result[wit_types.Result[wit_types.Option[*Fields], ErrorCode], wit_types.Unit]](result30)
	default:
		panic("unreachable")
	}
	result32 := option31
	return result32

}

//go:wasmimport wasi:http/types@0.2.0 [constructor]outgoing-response
func wasm_import_constructor_outgoing_response(arg0 int32) int32

func MakeOutgoingResponse(headers *Fields) *OutgoingResponse {

	result := wasm_import_constructor_outgoing_response((headers).TakeHandle())
	return OutgoingResponseFromOwnHandle(int32(uintptr(result)))

}

//go:wasmimport wasi:http/types@0.2.0 [method]outgoing-response.status-code
func wasm_import_method_outgoing_response_status_code(arg0 int32) int32

func (self *OutgoingResponse) StatusCode() uint16 {

	result := wasm_import_method_outgoing_response_status_code((self).Handle())
	return uint16(result)

}

//go:wasmimport wasi:http/types@0.2.0 [method]outgoing-response.set-status-code
func wasm_import_method_outgoing_response_set_status_code(arg0 int32, arg1 int32) int32

func (self *OutgoingResponse) SetStatusCode(statusCode uint16) wit_types.Result[wit_types.Unit, wit_types.Unit] {

	result := wasm_import_method_outgoing_response_set_status_code((self).Handle(), int32(statusCode))
	var result0 wit_types.Result[wit_types.Unit, wit_types.Unit]
	switch result {
	case 0:

		result0 = wit_types.Ok[wit_types.Unit, wit_types.Unit](wit_types.Unit{})
	case 1:

		result0 = wit_types.Err[wit_types.Unit, wit_types.Unit](wit_types.Unit{})
	default:
		panic("unreachable")
	}
	return result0

}

//go:wasmimport wasi:http/types@0.2.0 [method]outgoing-response.headers
func wasm_import_method_outgoing_response_headers(arg0 int32) int32

func (self *OutgoingResponse) Headers() *Fields {

	result := wasm_import_method_outgoing_response_headers((self).Handle())
	return FieldsFromOwnHandle(int32(uintptr(result)))

}

//go:wasmimport wasi:http/types@0.2.0 [method]outgoing-response.body
func wasm_import_method_outgoing_response_body(arg0 int32, arg1 uintptr)

func (self *OutgoingResponse) Body() wit_types.Result[*OutgoingBody, wit_types.Unit] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, 8, 4))
	wasm_import_method_outgoing_response_body((self).Handle(), returnArea)
	var result wit_types.Result[*OutgoingBody, wit_types.Unit]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		result = wit_types.Ok[*OutgoingBody, wit_types.Unit](OutgoingBodyFromOwnHandle(int32(uintptr(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 4))))))
	case 1:

		result = wit_types.Err[*OutgoingBody, wit_types.Unit](wit_types.Unit{})
	default:
		panic("unreachable")
	}
	result0 := result
	return result0

}

//go:wasmimport wasi:http/types@0.2.0 [method]outgoing-body.write
func wasm_import_method_outgoing_body_write(arg0 int32, arg1 uintptr)

func (self *OutgoingBody) Write() wit_types.Result[*wasi_io_streams.OutputStream, wit_types.Unit] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, 8, 4))
	wasm_import_method_outgoing_body_write((self).Handle(), returnArea)
	var result wit_types.Result[*wasi_io_streams.OutputStream, wit_types.Unit]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		result = wit_types.Ok[*wasi_io_streams.OutputStream, wit_types.Unit](wasi_io_streams.OutputStreamFromOwnHandle(int32(uintptr(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 4))))))
	case 1:

		result = wit_types.Err[*wasi_io_streams.OutputStream, wit_types.Unit](wit_types.Unit{})
	default:
		panic("unreachable")
	}
	result0 := result
	return result0

}

//go:wasmimport wasi:http/types@0.2.0 [static]outgoing-body.finish
func wasm_import_static_outgoing_body_finish(arg0 int32, arg1 int32, arg2 int32, arg3 uintptr)

func OutgoingBodyFinish(this *OutgoingBody, trailers wit_types.Option[*Fields]) wit_types.Result[wit_types.Unit, ErrorCode] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, (24 + 4*4), 8))
	var option int32
	var option0 int32
	switch trailers.Tag() {
	case wit_types.OptionNone:

		option = int32(0)
		option0 = 0
	case wit_types.OptionSome:
		payload := trailers.Some()

		option = int32(1)
		option0 = (payload).TakeHandle()
	default:
		panic("unreachable")
	}
	wasm_import_static_outgoing_body_finish((this).TakeHandle(), option, option0, returnArea)
	var result wit_types.Result[wit_types.Unit, ErrorCode]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		result = wit_types.Ok[wit_types.Unit, ErrorCode](wit_types.Unit{})
	case 1:
		var variant ErrorCode
		switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 8))) {
		case 0:

			variant = MakeErrorCodeDnsTimeout()

		case 1:
			var option1 wit_types.Option[string]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option1 = wit_types.None[string]()
			case 1:
				value := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 1*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 2*4))))

				option1 = wit_types.Some[string](value)
			default:
				panic("unreachable")
			}
			var option2 wit_types.Option[uint16]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 3*4)))) {
			case 0:

				option2 = wit_types.None[uint16]()
			case 1:

				option2 = wit_types.Some[uint16](uint16(uint16(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (18 + 3*4))))))
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeDnsError(DnsErrorPayload{option1, option2})

		case 2:

			variant = MakeErrorCodeDestinationNotFound()

		case 3:

			variant = MakeErrorCodeDestinationUnavailable()

		case 4:

			variant = MakeErrorCodeDestinationIpProhibited()

		case 5:

			variant = MakeErrorCodeDestinationIpUnroutable()

		case 6:

			variant = MakeErrorCodeConnectionRefused()

		case 7:

			variant = MakeErrorCodeConnectionTerminated()

		case 8:

			variant = MakeErrorCodeConnectionTimeout()

		case 9:

			variant = MakeErrorCodeConnectionReadTimeout()

		case 10:

			variant = MakeErrorCodeConnectionWriteTimeout()

		case 11:

			variant = MakeErrorCodeConnectionLimitReached()

		case 12:

			variant = MakeErrorCodeTlsProtocolError()

		case 13:

			variant = MakeErrorCodeTlsCertificateError()

		case 14:
			var option3 wit_types.Option[uint8]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option3 = wit_types.None[uint8]()
			case 1:

				option3 = wit_types.Some[uint8](uint8(uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 17)))))
			default:
				panic("unreachable")
			}
			var option5 wit_types.Option[string]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 1*4)))) {
			case 0:

				option5 = wit_types.None[string]()
			case 1:
				value4 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 2*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 3*4))))

				option5 = wit_types.Some[string](value4)
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeTlsAlertReceived(TlsAlertReceivedPayload{option3, option5})

		case 15:

			variant = MakeErrorCodeHttpRequestDenied()

		case 16:

			variant = MakeErrorCodeHttpRequestLengthRequired()

		case 17:
			var option6 wit_types.Option[uint64]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option6 = wit_types.None[uint64]()
			case 1:

				option6 = wit_types.Some[uint64](uint64(*(*int64)(unsafe.Add(unsafe.Pointer(returnArea), 24))))
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeHttpRequestBodySize(option6)

		case 18:

			variant = MakeErrorCodeHttpRequestMethodInvalid()

		case 19:

			variant = MakeErrorCodeHttpRequestUriInvalid()

		case 20:

			variant = MakeErrorCodeHttpRequestUriTooLong()

		case 21:
			var option7 wit_types.Option[uint32]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option7 = wit_types.None[uint32]()
			case 1:

				option7 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 20))))
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeHttpRequestHeaderSectionSize(option7)

		case 22:
			var option11 wit_types.Option[FieldSizePayload]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option11 = wit_types.None[FieldSizePayload]()
			case 1:
				var option9 wit_types.Option[string]
				switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 1*4)))) {
				case 0:

					option9 = wit_types.None[string]()
				case 1:
					value8 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 2*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 3*4))))

					option9 = wit_types.Some[string](value8)
				default:
					panic("unreachable")
				}
				var option10 wit_types.Option[uint32]
				switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 4*4)))) {
				case 0:

					option10 = wit_types.None[uint32]()
				case 1:

					option10 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), (20 + 4*4)))))
				default:
					panic("unreachable")
				}

				option11 = wit_types.Some[FieldSizePayload](FieldSizePayload{option9, option10})
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeHttpRequestHeaderSize(option11)

		case 23:
			var option12 wit_types.Option[uint32]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option12 = wit_types.None[uint32]()
			case 1:

				option12 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 20))))
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeHttpRequestTrailerSectionSize(option12)

		case 24:
			var option14 wit_types.Option[string]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option14 = wit_types.None[string]()
			case 1:
				value13 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 1*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 2*4))))

				option14 = wit_types.Some[string](value13)
			default:
				panic("unreachable")
			}
			var option15 wit_types.Option[uint32]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 3*4)))) {
			case 0:

				option15 = wit_types.None[uint32]()
			case 1:

				option15 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), (20 + 3*4)))))
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeHttpRequestTrailerSize(FieldSizePayload{option14, option15})

		case 25:

			variant = MakeErrorCodeHttpResponseIncomplete()

		case 26:
			var option16 wit_types.Option[uint32]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option16 = wit_types.None[uint32]()
			case 1:

				option16 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 20))))
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeHttpResponseHeaderSectionSize(option16)

		case 27:
			var option18 wit_types.Option[string]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option18 = wit_types.None[string]()
			case 1:
				value17 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 1*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 2*4))))

				option18 = wit_types.Some[string](value17)
			default:
				panic("unreachable")
			}
			var option19 wit_types.Option[uint32]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 3*4)))) {
			case 0:

				option19 = wit_types.None[uint32]()
			case 1:

				option19 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), (20 + 3*4)))))
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeHttpResponseHeaderSize(FieldSizePayload{option18, option19})

		case 28:
			var option20 wit_types.Option[uint64]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option20 = wit_types.None[uint64]()
			case 1:

				option20 = wit_types.Some[uint64](uint64(*(*int64)(unsafe.Add(unsafe.Pointer(returnArea), 24))))
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeHttpResponseBodySize(option20)

		case 29:
			var option21 wit_types.Option[uint32]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option21 = wit_types.None[uint32]()
			case 1:

				option21 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 20))))
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeHttpResponseTrailerSectionSize(option21)

		case 30:
			var option23 wit_types.Option[string]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option23 = wit_types.None[string]()
			case 1:
				value22 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 1*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 2*4))))

				option23 = wit_types.Some[string](value22)
			default:
				panic("unreachable")
			}
			var option24 wit_types.Option[uint32]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 3*4)))) {
			case 0:

				option24 = wit_types.None[uint32]()
			case 1:

				option24 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), (20 + 3*4)))))
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeHttpResponseTrailerSize(FieldSizePayload{option23, option24})

		case 31:
			var option26 wit_types.Option[string]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option26 = wit_types.None[string]()
			case 1:
				value25 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 1*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 2*4))))

				option26 = wit_types.Some[string](value25)
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeHttpResponseTransferCoding(option26)

		case 32:
			var option28 wit_types.Option[string]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option28 = wit_types.None[string]()
			case 1:
				value27 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 1*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 2*4))))

				option28 = wit_types.Some[string](value27)
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeHttpResponseContentCoding(option28)

		case 33:

			variant = MakeErrorCodeHttpResponseTimeout()

		case 34:

			variant = MakeErrorCodeHttpUpgradeFailed()

		case 35:

			variant = MakeErrorCodeHttpProtocolError()

		case 36:

			variant = MakeErrorCodeLoopDetected()

		case 37:

			variant = MakeErrorCodeConfigurationError()

		case 38:
			var option30 wit_types.Option[string]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option30 = wit_types.None[string]()
			case 1:
				value29 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 1*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 2*4))))

				option30 = wit_types.Some[string](value29)
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeInternalError(option30)

		default:
			panic("unreachable")
		}

		result = wit_types.Err[wit_types.Unit, ErrorCode](variant)
	default:
		panic("unreachable")
	}
	result31 := result
	return result31

}

//go:wasmimport wasi:http/types@0.2.0 [method]future-incoming-response.subscribe
func wasm_import_method_future_incoming_response_subscribe(arg0 int32) int32

func (self *FutureIncomingResponse) Subscribe() *wasi_io_poll.Pollable {

	result := wasm_import_method_future_incoming_response_subscribe((self).Handle())
	return wasi_io_poll.PollableFromOwnHandle(int32(uintptr(result)))

}

//go:wasmimport wasi:http/types@0.2.0 [method]future-incoming-response.get
func wasm_import_method_future_incoming_response_get(arg0 int32, arg1 uintptr)

func (self *FutureIncomingResponse) Get() wit_types.Option[wit_types.Result[wit_types.Result[*IncomingResponse, ErrorCode], wit_types.Unit]] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, (40 + 4*4), 8))
	wasm_import_method_future_incoming_response_get((self).Handle(), returnArea)
	var option30 wit_types.Option[wit_types.Result[wit_types.Result[*IncomingResponse, ErrorCode], wit_types.Unit]]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		option30 = wit_types.None[wit_types.Result[wit_types.Result[*IncomingResponse, ErrorCode], wit_types.Unit]]()
	case 1:
		var result29 wit_types.Result[wit_types.Result[*IncomingResponse, ErrorCode], wit_types.Unit]
		switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 8))) {
		case 0:
			var result wit_types.Result[*IncomingResponse, ErrorCode]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				result = wit_types.Ok[*IncomingResponse, ErrorCode](IncomingResponseFromOwnHandle(int32(uintptr(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 24))))))
			case 1:
				var variant ErrorCode
				switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 24))) {
				case 0:

					variant = MakeErrorCodeDnsTimeout()

				case 1:
					var option wit_types.Option[string]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option = wit_types.None[string]()
					case 1:
						value := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 1*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 2*4))))

						option = wit_types.Some[string](value)
					default:
						panic("unreachable")
					}
					var option0 wit_types.Option[uint16]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 3*4)))) {
					case 0:

						option0 = wit_types.None[uint16]()
					case 1:

						option0 = wit_types.Some[uint16](uint16(uint16(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (34 + 3*4))))))
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeDnsError(DnsErrorPayload{option, option0})

				case 2:

					variant = MakeErrorCodeDestinationNotFound()

				case 3:

					variant = MakeErrorCodeDestinationUnavailable()

				case 4:

					variant = MakeErrorCodeDestinationIpProhibited()

				case 5:

					variant = MakeErrorCodeDestinationIpUnroutable()

				case 6:

					variant = MakeErrorCodeConnectionRefused()

				case 7:

					variant = MakeErrorCodeConnectionTerminated()

				case 8:

					variant = MakeErrorCodeConnectionTimeout()

				case 9:

					variant = MakeErrorCodeConnectionReadTimeout()

				case 10:

					variant = MakeErrorCodeConnectionWriteTimeout()

				case 11:

					variant = MakeErrorCodeConnectionLimitReached()

				case 12:

					variant = MakeErrorCodeTlsProtocolError()

				case 13:

					variant = MakeErrorCodeTlsCertificateError()

				case 14:
					var option1 wit_types.Option[uint8]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option1 = wit_types.None[uint8]()
					case 1:

						option1 = wit_types.Some[uint8](uint8(uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 33)))))
					default:
						panic("unreachable")
					}
					var option3 wit_types.Option[string]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 1*4)))) {
					case 0:

						option3 = wit_types.None[string]()
					case 1:
						value2 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 2*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 3*4))))

						option3 = wit_types.Some[string](value2)
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeTlsAlertReceived(TlsAlertReceivedPayload{option1, option3})

				case 15:

					variant = MakeErrorCodeHttpRequestDenied()

				case 16:

					variant = MakeErrorCodeHttpRequestLengthRequired()

				case 17:
					var option4 wit_types.Option[uint64]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option4 = wit_types.None[uint64]()
					case 1:

						option4 = wit_types.Some[uint64](uint64(*(*int64)(unsafe.Add(unsafe.Pointer(returnArea), 40))))
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeHttpRequestBodySize(option4)

				case 18:

					variant = MakeErrorCodeHttpRequestMethodInvalid()

				case 19:

					variant = MakeErrorCodeHttpRequestUriInvalid()

				case 20:

					variant = MakeErrorCodeHttpRequestUriTooLong()

				case 21:
					var option5 wit_types.Option[uint32]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option5 = wit_types.None[uint32]()
					case 1:

						option5 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 36))))
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeHttpRequestHeaderSectionSize(option5)

				case 22:
					var option9 wit_types.Option[FieldSizePayload]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option9 = wit_types.None[FieldSizePayload]()
					case 1:
						var option7 wit_types.Option[string]
						switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 1*4)))) {
						case 0:

							option7 = wit_types.None[string]()
						case 1:
							value6 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 2*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 3*4))))

							option7 = wit_types.Some[string](value6)
						default:
							panic("unreachable")
						}
						var option8 wit_types.Option[uint32]
						switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 4*4)))) {
						case 0:

							option8 = wit_types.None[uint32]()
						case 1:

							option8 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), (36 + 4*4)))))
						default:
							panic("unreachable")
						}

						option9 = wit_types.Some[FieldSizePayload](FieldSizePayload{option7, option8})
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeHttpRequestHeaderSize(option9)

				case 23:
					var option10 wit_types.Option[uint32]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option10 = wit_types.None[uint32]()
					case 1:

						option10 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 36))))
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeHttpRequestTrailerSectionSize(option10)

				case 24:
					var option12 wit_types.Option[string]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option12 = wit_types.None[string]()
					case 1:
						value11 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 1*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 2*4))))

						option12 = wit_types.Some[string](value11)
					default:
						panic("unreachable")
					}
					var option13 wit_types.Option[uint32]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 3*4)))) {
					case 0:

						option13 = wit_types.None[uint32]()
					case 1:

						option13 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), (36 + 3*4)))))
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeHttpRequestTrailerSize(FieldSizePayload{option12, option13})

				case 25:

					variant = MakeErrorCodeHttpResponseIncomplete()

				case 26:
					var option14 wit_types.Option[uint32]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option14 = wit_types.None[uint32]()
					case 1:

						option14 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 36))))
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeHttpResponseHeaderSectionSize(option14)

				case 27:
					var option16 wit_types.Option[string]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option16 = wit_types.None[string]()
					case 1:
						value15 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 1*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 2*4))))

						option16 = wit_types.Some[string](value15)
					default:
						panic("unreachable")
					}
					var option17 wit_types.Option[uint32]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 3*4)))) {
					case 0:

						option17 = wit_types.None[uint32]()
					case 1:

						option17 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), (36 + 3*4)))))
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeHttpResponseHeaderSize(FieldSizePayload{option16, option17})

				case 28:
					var option18 wit_types.Option[uint64]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option18 = wit_types.None[uint64]()
					case 1:

						option18 = wit_types.Some[uint64](uint64(*(*int64)(unsafe.Add(unsafe.Pointer(returnArea), 40))))
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeHttpResponseBodySize(option18)

				case 29:
					var option19 wit_types.Option[uint32]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option19 = wit_types.None[uint32]()
					case 1:

						option19 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 36))))
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeHttpResponseTrailerSectionSize(option19)

				case 30:
					var option21 wit_types.Option[string]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option21 = wit_types.None[string]()
					case 1:
						value20 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 1*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 2*4))))

						option21 = wit_types.Some[string](value20)
					default:
						panic("unreachable")
					}
					var option22 wit_types.Option[uint32]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 3*4)))) {
					case 0:

						option22 = wit_types.None[uint32]()
					case 1:

						option22 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), (36 + 3*4)))))
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeHttpResponseTrailerSize(FieldSizePayload{option21, option22})

				case 31:
					var option24 wit_types.Option[string]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option24 = wit_types.None[string]()
					case 1:
						value23 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 1*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 2*4))))

						option24 = wit_types.Some[string](value23)
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeHttpResponseTransferCoding(option24)

				case 32:
					var option26 wit_types.Option[string]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option26 = wit_types.None[string]()
					case 1:
						value25 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 1*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 2*4))))

						option26 = wit_types.Some[string](value25)
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeHttpResponseContentCoding(option26)

				case 33:

					variant = MakeErrorCodeHttpResponseTimeout()

				case 34:

					variant = MakeErrorCodeHttpUpgradeFailed()

				case 35:

					variant = MakeErrorCodeHttpProtocolError()

				case 36:

					variant = MakeErrorCodeLoopDetected()

				case 37:

					variant = MakeErrorCodeConfigurationError()

				case 38:
					var option28 wit_types.Option[string]
					switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 32))) {
					case 0:

						option28 = wit_types.None[string]()
					case 1:
						value27 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 1*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 2*4))))

						option28 = wit_types.Some[string](value27)
					default:
						panic("unreachable")
					}

					variant = MakeErrorCodeInternalError(option28)

				default:
					panic("unreachable")
				}

				result = wit_types.Err[*IncomingResponse, ErrorCode](variant)
			default:
				panic("unreachable")
			}

			result29 = wit_types.Ok[wit_types.Result[*IncomingResponse, ErrorCode], wit_types.Unit](result)
		case 1:

			result29 = wit_types.Err[wit_types.Result[*IncomingResponse, ErrorCode], wit_types.Unit](wit_types.Unit{})
		default:
			panic("unreachable")
		}

		option30 = wit_types.Some[wit_types.Result[wit_types.Result[*IncomingResponse, ErrorCode], wit_types.Unit]](result29)
	default:
		panic("unreachable")
	}
	result31 := option30
	return result31

}

//go:wasmimport wasi:http/types@0.2.0 http-error-code
func wasm_import_http_error_code(arg0 int32, arg1 uintptr)

func HttpErrorCode(err *wasi_io_error.Error) wit_types.Option[ErrorCode] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, (24 + 4*4), 8))
	wasm_import_http_error_code((err).Handle(), returnArea)
	var option29 wit_types.Option[ErrorCode]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		option29 = wit_types.None[ErrorCode]()
	case 1:
		var variant ErrorCode
		switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 8))) {
		case 0:

			variant = MakeErrorCodeDnsTimeout()

		case 1:
			var option wit_types.Option[string]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option = wit_types.None[string]()
			case 1:
				value := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 1*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 2*4))))

				option = wit_types.Some[string](value)
			default:
				panic("unreachable")
			}
			var option0 wit_types.Option[uint16]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 3*4)))) {
			case 0:

				option0 = wit_types.None[uint16]()
			case 1:

				option0 = wit_types.Some[uint16](uint16(uint16(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (18 + 3*4))))))
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeDnsError(DnsErrorPayload{option, option0})

		case 2:

			variant = MakeErrorCodeDestinationNotFound()

		case 3:

			variant = MakeErrorCodeDestinationUnavailable()

		case 4:

			variant = MakeErrorCodeDestinationIpProhibited()

		case 5:

			variant = MakeErrorCodeDestinationIpUnroutable()

		case 6:

			variant = MakeErrorCodeConnectionRefused()

		case 7:

			variant = MakeErrorCodeConnectionTerminated()

		case 8:

			variant = MakeErrorCodeConnectionTimeout()

		case 9:

			variant = MakeErrorCodeConnectionReadTimeout()

		case 10:

			variant = MakeErrorCodeConnectionWriteTimeout()

		case 11:

			variant = MakeErrorCodeConnectionLimitReached()

		case 12:

			variant = MakeErrorCodeTlsProtocolError()

		case 13:

			variant = MakeErrorCodeTlsCertificateError()

		case 14:
			var option1 wit_types.Option[uint8]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option1 = wit_types.None[uint8]()
			case 1:

				option1 = wit_types.Some[uint8](uint8(uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 17)))))
			default:
				panic("unreachable")
			}
			var option3 wit_types.Option[string]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 1*4)))) {
			case 0:

				option3 = wit_types.None[string]()
			case 1:
				value2 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 2*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 3*4))))

				option3 = wit_types.Some[string](value2)
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeTlsAlertReceived(TlsAlertReceivedPayload{option1, option3})

		case 15:

			variant = MakeErrorCodeHttpRequestDenied()

		case 16:

			variant = MakeErrorCodeHttpRequestLengthRequired()

		case 17:
			var option4 wit_types.Option[uint64]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option4 = wit_types.None[uint64]()
			case 1:

				option4 = wit_types.Some[uint64](uint64(*(*int64)(unsafe.Add(unsafe.Pointer(returnArea), 24))))
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeHttpRequestBodySize(option4)

		case 18:

			variant = MakeErrorCodeHttpRequestMethodInvalid()

		case 19:

			variant = MakeErrorCodeHttpRequestUriInvalid()

		case 20:

			variant = MakeErrorCodeHttpRequestUriTooLong()

		case 21:
			var option5 wit_types.Option[uint32]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option5 = wit_types.None[uint32]()
			case 1:

				option5 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 20))))
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeHttpRequestHeaderSectionSize(option5)

		case 22:
			var option9 wit_types.Option[FieldSizePayload]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option9 = wit_types.None[FieldSizePayload]()
			case 1:
				var option7 wit_types.Option[string]
				switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 1*4)))) {
				case 0:

					option7 = wit_types.None[string]()
				case 1:
					value6 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 2*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 3*4))))

					option7 = wit_types.Some[string](value6)
				default:
					panic("unreachable")
				}
				var option8 wit_types.Option[uint32]
				switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 4*4)))) {
				case 0:

					option8 = wit_types.None[uint32]()
				case 1:

					option8 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), (20 + 4*4)))))
				default:
					panic("unreachable")
				}

				option9 = wit_types.Some[FieldSizePayload](FieldSizePayload{option7, option8})
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeHttpRequestHeaderSize(option9)

		case 23:
			var option10 wit_types.Option[uint32]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option10 = wit_types.None[uint32]()
			case 1:

				option10 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 20))))
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeHttpRequestTrailerSectionSize(option10)

		case 24:
			var option12 wit_types.Option[string]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option12 = wit_types.None[string]()
			case 1:
				value11 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 1*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 2*4))))

				option12 = wit_types.Some[string](value11)
			default:
				panic("unreachable")
			}
			var option13 wit_types.Option[uint32]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 3*4)))) {
			case 0:

				option13 = wit_types.None[uint32]()
			case 1:

				option13 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), (20 + 3*4)))))
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeHttpRequestTrailerSize(FieldSizePayload{option12, option13})

		case 25:

			variant = MakeErrorCodeHttpResponseIncomplete()

		case 26:
			var option14 wit_types.Option[uint32]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option14 = wit_types.None[uint32]()
			case 1:

				option14 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 20))))
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeHttpResponseHeaderSectionSize(option14)

		case 27:
			var option16 wit_types.Option[string]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option16 = wit_types.None[string]()
			case 1:
				value15 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 1*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 2*4))))

				option16 = wit_types.Some[string](value15)
			default:
				panic("unreachable")
			}
			var option17 wit_types.Option[uint32]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 3*4)))) {
			case 0:

				option17 = wit_types.None[uint32]()
			case 1:

				option17 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), (20 + 3*4)))))
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeHttpResponseHeaderSize(FieldSizePayload{option16, option17})

		case 28:
			var option18 wit_types.Option[uint64]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option18 = wit_types.None[uint64]()
			case 1:

				option18 = wit_types.Some[uint64](uint64(*(*int64)(unsafe.Add(unsafe.Pointer(returnArea), 24))))
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeHttpResponseBodySize(option18)

		case 29:
			var option19 wit_types.Option[uint32]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option19 = wit_types.None[uint32]()
			case 1:

				option19 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 20))))
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeHttpResponseTrailerSectionSize(option19)

		case 30:
			var option21 wit_types.Option[string]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option21 = wit_types.None[string]()
			case 1:
				value20 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 1*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 2*4))))

				option21 = wit_types.Some[string](value20)
			default:
				panic("unreachable")
			}
			var option22 wit_types.Option[uint32]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 3*4)))) {
			case 0:

				option22 = wit_types.None[uint32]()
			case 1:

				option22 = wit_types.Some[uint32](uint32(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), (20 + 3*4)))))
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeHttpResponseTrailerSize(FieldSizePayload{option21, option22})

		case 31:
			var option24 wit_types.Option[string]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option24 = wit_types.None[string]()
			case 1:
				value23 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 1*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 2*4))))

				option24 = wit_types.Some[string](value23)
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeHttpResponseTransferCoding(option24)

		case 32:
			var option26 wit_types.Option[string]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option26 = wit_types.None[string]()
			case 1:
				value25 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 1*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 2*4))))

				option26 = wit_types.Some[string](value25)
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeHttpResponseContentCoding(option26)

		case 33:

			variant = MakeErrorCodeHttpResponseTimeout()

		case 34:

			variant = MakeErrorCodeHttpUpgradeFailed()

		case 35:

			variant = MakeErrorCodeHttpProtocolError()

		case 36:

			variant = MakeErrorCodeLoopDetected()

		case 37:

			variant = MakeErrorCodeConfigurationError()

		case 38:
			var option28 wit_types.Option[string]
			switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 16))) {
			case 0:

				option28 = wit_types.None[string]()
			case 1:
				value27 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 1*4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 2*4))))

				option28 = wit_types.Some[string](value27)
			default:
				panic("unreachable")
			}

			variant = MakeErrorCodeInternalError(option28)

		default:
			panic("unreachable")
		}

		option29 = wit_types.Some[ErrorCode](variant)
	default:
		panic("unreachable")
	}
	result := option29
	return result

}
