// Generated by `wit-bindgen` 0.51.0. DO NOT EDIT!
//
// This code was generated from the following packages:
//     wasi:io@0.2.0
//     wasi:clocks@0.2.0
//     wasi:random@0.2.0
//     wasi:cli@0.2.0
//     wasi:http@0.2.0
//     jamesstocktonj1:componentize-sdk

package wasi_io_streams

import (
	"github.com/bytecodealliance/wit-bindgen/wit_runtime"
	"github.com/bytecodealliance/wit-bindgen/wit_types"
	"github.com/jamesstocktonj1/componentize-sdk/gen/wasi_io_error"
	"github.com/jamesstocktonj1/componentize-sdk/gen/wasi_io_poll"
	"runtime"
	"unsafe"
)

type Error = wasi_io_error.Error
type Pollable = wasi_io_poll.Pollable

const (
	StreamErrorLastOperationFailed uint8 = 0
	StreamErrorClosed              uint8 = 1
)

type StreamError struct {
	tag   uint8
	value any
}

func (self StreamError) Tag() uint8 {
	return self.tag
}

func (self StreamError) LastOperationFailed() *wasi_io_error.Error {
	if self.tag != StreamErrorLastOperationFailed {
		panic("tag mismatch")
	}
	return self.value.(*wasi_io_error.Error)
}

func MakeStreamErrorLastOperationFailed(value *wasi_io_error.Error) StreamError {
	return StreamError{StreamErrorLastOperationFailed, value}
}
func MakeStreamErrorClosed() StreamError {
	return StreamError{StreamErrorClosed, nil}
}

//go:wasmimport wasi:io/streams@0.2.0 [resource-drop]input-stream
func resourceDropInputStream(handle int32)

type InputStream struct {
	handle *wit_runtime.Handle
}

func (self *InputStream) TakeHandle() int32 {
	return self.handle.Take()
}

func (self *InputStream) SetHandle(handle int32) {
	self.handle.Set(handle)
}

func (self *InputStream) Handle() int32 {
	return self.handle.Use()
}

func (self *InputStream) Drop() {
	handle := self.handle.TakeOrNil()
	if handle != 0 {
		resourceDropInputStream(handle)
	}
}

func InputStreamFromOwnHandle(handleValue int32) *InputStream {
	handle := wit_runtime.MakeHandle(handleValue)
	value := &InputStream{handle}
	runtime.AddCleanup(value, func(_ int) {
		handleValue := handle.TakeOrNil()
		if handleValue != 0 {
			resourceDropInputStream(handleValue)
		}
	}, 0)
	return value
}

func InputStreamFromBorrowHandle(handleValue int32) *InputStream {
	return InputStreamFromOwnHandle(handleValue)
}

//go:wasmimport wasi:io/streams@0.2.0 [resource-drop]output-stream
func resourceDropOutputStream(handle int32)

type OutputStream struct {
	handle *wit_runtime.Handle
}

func (self *OutputStream) TakeHandle() int32 {
	return self.handle.Take()
}

func (self *OutputStream) SetHandle(handle int32) {
	self.handle.Set(handle)
}

func (self *OutputStream) Handle() int32 {
	return self.handle.Use()
}

func (self *OutputStream) Drop() {
	handle := self.handle.TakeOrNil()
	if handle != 0 {
		resourceDropOutputStream(handle)
	}
}

func OutputStreamFromOwnHandle(handleValue int32) *OutputStream {
	handle := wit_runtime.MakeHandle(handleValue)
	value := &OutputStream{handle}
	runtime.AddCleanup(value, func(_ int) {
		handleValue := handle.TakeOrNil()
		if handleValue != 0 {
			resourceDropOutputStream(handleValue)
		}
	}, 0)
	return value
}

func OutputStreamFromBorrowHandle(handleValue int32) *OutputStream {
	return OutputStreamFromOwnHandle(handleValue)
}

//go:wasmimport wasi:io/streams@0.2.0 [method]input-stream.read
func wasm_import_method_input_stream_read(arg0 int32, arg1 int64, arg2 uintptr)

func (self *InputStream) Read(len uint64) wit_types.Result[[]uint8, StreamError] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, (3 * 4), 4))
	wasm_import_method_input_stream_read((self).Handle(), int64(len), returnArea)
	var result wit_types.Result[[]uint8, StreamError]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:
		value := unsafe.Slice((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 4))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (2 * 4))))

		result = wit_types.Ok[[]uint8, StreamError](value)
	case 1:
		var variant StreamError
		switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 4))) {
		case 0:

			variant = MakeStreamErrorLastOperationFailed(wasi_io_error.ErrorFromOwnHandle(int32(uintptr(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), (4 + 1*4)))))))

		case 1:

			variant = MakeStreamErrorClosed()

		default:
			panic("unreachable")
		}

		result = wit_types.Err[[]uint8, StreamError](variant)
	default:
		panic("unreachable")
	}
	result0 := result
	return result0

}

//go:wasmimport wasi:io/streams@0.2.0 [method]input-stream.blocking-read
func wasm_import_method_input_stream_blocking_read(arg0 int32, arg1 int64, arg2 uintptr)

func (self *InputStream) BlockingRead(len uint64) wit_types.Result[[]uint8, StreamError] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, (3 * 4), 4))
	wasm_import_method_input_stream_blocking_read((self).Handle(), int64(len), returnArea)
	var result wit_types.Result[[]uint8, StreamError]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:
		value := unsafe.Slice((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 4))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (2 * 4))))

		result = wit_types.Ok[[]uint8, StreamError](value)
	case 1:
		var variant StreamError
		switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 4))) {
		case 0:

			variant = MakeStreamErrorLastOperationFailed(wasi_io_error.ErrorFromOwnHandle(int32(uintptr(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), (4 + 1*4)))))))

		case 1:

			variant = MakeStreamErrorClosed()

		default:
			panic("unreachable")
		}

		result = wit_types.Err[[]uint8, StreamError](variant)
	default:
		panic("unreachable")
	}
	result0 := result
	return result0

}

//go:wasmimport wasi:io/streams@0.2.0 [method]input-stream.skip
func wasm_import_method_input_stream_skip(arg0 int32, arg1 int64, arg2 uintptr)

func (self *InputStream) Skip(len uint64) wit_types.Result[uint64, StreamError] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, 16, 8))
	wasm_import_method_input_stream_skip((self).Handle(), int64(len), returnArea)
	var result wit_types.Result[uint64, StreamError]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		result = wit_types.Ok[uint64, StreamError](uint64(*(*int64)(unsafe.Add(unsafe.Pointer(returnArea), 8))))
	case 1:
		var variant StreamError
		switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 8))) {
		case 0:

			variant = MakeStreamErrorLastOperationFailed(wasi_io_error.ErrorFromOwnHandle(int32(uintptr(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 12))))))

		case 1:

			variant = MakeStreamErrorClosed()

		default:
			panic("unreachable")
		}

		result = wit_types.Err[uint64, StreamError](variant)
	default:
		panic("unreachable")
	}
	result0 := result
	return result0

}

//go:wasmimport wasi:io/streams@0.2.0 [method]input-stream.blocking-skip
func wasm_import_method_input_stream_blocking_skip(arg0 int32, arg1 int64, arg2 uintptr)

func (self *InputStream) BlockingSkip(len uint64) wit_types.Result[uint64, StreamError] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, 16, 8))
	wasm_import_method_input_stream_blocking_skip((self).Handle(), int64(len), returnArea)
	var result wit_types.Result[uint64, StreamError]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		result = wit_types.Ok[uint64, StreamError](uint64(*(*int64)(unsafe.Add(unsafe.Pointer(returnArea), 8))))
	case 1:
		var variant StreamError
		switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 8))) {
		case 0:

			variant = MakeStreamErrorLastOperationFailed(wasi_io_error.ErrorFromOwnHandle(int32(uintptr(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 12))))))

		case 1:

			variant = MakeStreamErrorClosed()

		default:
			panic("unreachable")
		}

		result = wit_types.Err[uint64, StreamError](variant)
	default:
		panic("unreachable")
	}
	result0 := result
	return result0

}

//go:wasmimport wasi:io/streams@0.2.0 [method]input-stream.subscribe
func wasm_import_method_input_stream_subscribe(arg0 int32) int32

func (self *InputStream) Subscribe() *wasi_io_poll.Pollable {

	result := wasm_import_method_input_stream_subscribe((self).Handle())
	return wasi_io_poll.PollableFromOwnHandle(int32(uintptr(result)))

}

//go:wasmimport wasi:io/streams@0.2.0 [method]output-stream.check-write
func wasm_import_method_output_stream_check_write(arg0 int32, arg1 uintptr)

func (self *OutputStream) CheckWrite() wit_types.Result[uint64, StreamError] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, 16, 8))
	wasm_import_method_output_stream_check_write((self).Handle(), returnArea)
	var result wit_types.Result[uint64, StreamError]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		result = wit_types.Ok[uint64, StreamError](uint64(*(*int64)(unsafe.Add(unsafe.Pointer(returnArea), 8))))
	case 1:
		var variant StreamError
		switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 8))) {
		case 0:

			variant = MakeStreamErrorLastOperationFailed(wasi_io_error.ErrorFromOwnHandle(int32(uintptr(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 12))))))

		case 1:

			variant = MakeStreamErrorClosed()

		default:
			panic("unreachable")
		}

		result = wit_types.Err[uint64, StreamError](variant)
	default:
		panic("unreachable")
	}
	result0 := result
	return result0

}

//go:wasmimport wasi:io/streams@0.2.0 [method]output-stream.write
func wasm_import_method_output_stream_write(arg0 int32, arg1 uintptr, arg2 uint32, arg3 uintptr)

func (self *OutputStream) Write(contents []uint8) wit_types.Result[wit_types.Unit, StreamError] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, 12, 4))
	data := unsafe.Pointer(unsafe.SliceData(contents))
	pinner.Pin(data)
	wasm_import_method_output_stream_write((self).Handle(), uintptr(data), uint32(len(contents)), returnArea)
	var result wit_types.Result[wit_types.Unit, StreamError]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		result = wit_types.Ok[wit_types.Unit, StreamError](wit_types.Unit{})
	case 1:
		var variant StreamError
		switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 4))) {
		case 0:

			variant = MakeStreamErrorLastOperationFailed(wasi_io_error.ErrorFromOwnHandle(int32(uintptr(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 8))))))

		case 1:

			variant = MakeStreamErrorClosed()

		default:
			panic("unreachable")
		}

		result = wit_types.Err[wit_types.Unit, StreamError](variant)
	default:
		panic("unreachable")
	}
	result0 := result
	return result0

}

//go:wasmimport wasi:io/streams@0.2.0 [method]output-stream.blocking-write-and-flush
func wasm_import_method_output_stream_blocking_write_and_flush(arg0 int32, arg1 uintptr, arg2 uint32, arg3 uintptr)

func (self *OutputStream) BlockingWriteAndFlush(contents []uint8) wit_types.Result[wit_types.Unit, StreamError] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, 12, 4))
	data := unsafe.Pointer(unsafe.SliceData(contents))
	pinner.Pin(data)
	wasm_import_method_output_stream_blocking_write_and_flush((self).Handle(), uintptr(data), uint32(len(contents)), returnArea)
	var result wit_types.Result[wit_types.Unit, StreamError]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		result = wit_types.Ok[wit_types.Unit, StreamError](wit_types.Unit{})
	case 1:
		var variant StreamError
		switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 4))) {
		case 0:

			variant = MakeStreamErrorLastOperationFailed(wasi_io_error.ErrorFromOwnHandle(int32(uintptr(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 8))))))

		case 1:

			variant = MakeStreamErrorClosed()

		default:
			panic("unreachable")
		}

		result = wit_types.Err[wit_types.Unit, StreamError](variant)
	default:
		panic("unreachable")
	}
	result0 := result
	return result0

}

//go:wasmimport wasi:io/streams@0.2.0 [method]output-stream.flush
func wasm_import_method_output_stream_flush(arg0 int32, arg1 uintptr)

func (self *OutputStream) Flush() wit_types.Result[wit_types.Unit, StreamError] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, 12, 4))
	wasm_import_method_output_stream_flush((self).Handle(), returnArea)
	var result wit_types.Result[wit_types.Unit, StreamError]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		result = wit_types.Ok[wit_types.Unit, StreamError](wit_types.Unit{})
	case 1:
		var variant StreamError
		switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 4))) {
		case 0:

			variant = MakeStreamErrorLastOperationFailed(wasi_io_error.ErrorFromOwnHandle(int32(uintptr(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 8))))))

		case 1:

			variant = MakeStreamErrorClosed()

		default:
			panic("unreachable")
		}

		result = wit_types.Err[wit_types.Unit, StreamError](variant)
	default:
		panic("unreachable")
	}
	result0 := result
	return result0

}

//go:wasmimport wasi:io/streams@0.2.0 [method]output-stream.blocking-flush
func wasm_import_method_output_stream_blocking_flush(arg0 int32, arg1 uintptr)

func (self *OutputStream) BlockingFlush() wit_types.Result[wit_types.Unit, StreamError] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, 12, 4))
	wasm_import_method_output_stream_blocking_flush((self).Handle(), returnArea)
	var result wit_types.Result[wit_types.Unit, StreamError]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		result = wit_types.Ok[wit_types.Unit, StreamError](wit_types.Unit{})
	case 1:
		var variant StreamError
		switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 4))) {
		case 0:

			variant = MakeStreamErrorLastOperationFailed(wasi_io_error.ErrorFromOwnHandle(int32(uintptr(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 8))))))

		case 1:

			variant = MakeStreamErrorClosed()

		default:
			panic("unreachable")
		}

		result = wit_types.Err[wit_types.Unit, StreamError](variant)
	default:
		panic("unreachable")
	}
	result0 := result
	return result0

}

//go:wasmimport wasi:io/streams@0.2.0 [method]output-stream.subscribe
func wasm_import_method_output_stream_subscribe(arg0 int32) int32

func (self *OutputStream) Subscribe() *wasi_io_poll.Pollable {

	result := wasm_import_method_output_stream_subscribe((self).Handle())
	return wasi_io_poll.PollableFromOwnHandle(int32(uintptr(result)))

}

//go:wasmimport wasi:io/streams@0.2.0 [method]output-stream.write-zeroes
func wasm_import_method_output_stream_write_zeroes(arg0 int32, arg1 int64, arg2 uintptr)

func (self *OutputStream) WriteZeroes(len uint64) wit_types.Result[wit_types.Unit, StreamError] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, 12, 4))
	wasm_import_method_output_stream_write_zeroes((self).Handle(), int64(len), returnArea)
	var result wit_types.Result[wit_types.Unit, StreamError]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		result = wit_types.Ok[wit_types.Unit, StreamError](wit_types.Unit{})
	case 1:
		var variant StreamError
		switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 4))) {
		case 0:

			variant = MakeStreamErrorLastOperationFailed(wasi_io_error.ErrorFromOwnHandle(int32(uintptr(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 8))))))

		case 1:

			variant = MakeStreamErrorClosed()

		default:
			panic("unreachable")
		}

		result = wit_types.Err[wit_types.Unit, StreamError](variant)
	default:
		panic("unreachable")
	}
	result0 := result
	return result0

}

//go:wasmimport wasi:io/streams@0.2.0 [method]output-stream.blocking-write-zeroes-and-flush
func wasm_import_method_output_stream_blocking_write_zeroes_and_flush(arg0 int32, arg1 int64, arg2 uintptr)

func (self *OutputStream) BlockingWriteZeroesAndFlush(len uint64) wit_types.Result[wit_types.Unit, StreamError] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, 12, 4))
	wasm_import_method_output_stream_blocking_write_zeroes_and_flush((self).Handle(), int64(len), returnArea)
	var result wit_types.Result[wit_types.Unit, StreamError]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		result = wit_types.Ok[wit_types.Unit, StreamError](wit_types.Unit{})
	case 1:
		var variant StreamError
		switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 4))) {
		case 0:

			variant = MakeStreamErrorLastOperationFailed(wasi_io_error.ErrorFromOwnHandle(int32(uintptr(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 8))))))

		case 1:

			variant = MakeStreamErrorClosed()

		default:
			panic("unreachable")
		}

		result = wit_types.Err[wit_types.Unit, StreamError](variant)
	default:
		panic("unreachable")
	}
	result0 := result
	return result0

}

//go:wasmimport wasi:io/streams@0.2.0 [method]output-stream.splice
func wasm_import_method_output_stream_splice(arg0 int32, arg1 int32, arg2 int64, arg3 uintptr)

func (self *OutputStream) Splice(src *InputStream, len uint64) wit_types.Result[uint64, StreamError] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, 16, 8))
	wasm_import_method_output_stream_splice((self).Handle(), (src).Handle(), int64(len), returnArea)
	var result wit_types.Result[uint64, StreamError]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		result = wit_types.Ok[uint64, StreamError](uint64(*(*int64)(unsafe.Add(unsafe.Pointer(returnArea), 8))))
	case 1:
		var variant StreamError
		switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 8))) {
		case 0:

			variant = MakeStreamErrorLastOperationFailed(wasi_io_error.ErrorFromOwnHandle(int32(uintptr(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 12))))))

		case 1:

			variant = MakeStreamErrorClosed()

		default:
			panic("unreachable")
		}

		result = wit_types.Err[uint64, StreamError](variant)
	default:
		panic("unreachable")
	}
	result0 := result
	return result0

}

//go:wasmimport wasi:io/streams@0.2.0 [method]output-stream.blocking-splice
func wasm_import_method_output_stream_blocking_splice(arg0 int32, arg1 int32, arg2 int64, arg3 uintptr)

func (self *OutputStream) BlockingSplice(src *InputStream, len uint64) wit_types.Result[uint64, StreamError] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, 16, 8))
	wasm_import_method_output_stream_blocking_splice((self).Handle(), (src).Handle(), int64(len), returnArea)
	var result wit_types.Result[uint64, StreamError]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		result = wit_types.Ok[uint64, StreamError](uint64(*(*int64)(unsafe.Add(unsafe.Pointer(returnArea), 8))))
	case 1:
		var variant StreamError
		switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 8))) {
		case 0:

			variant = MakeStreamErrorLastOperationFailed(wasi_io_error.ErrorFromOwnHandle(int32(uintptr(*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), 12))))))

		case 1:

			variant = MakeStreamErrorClosed()

		default:
			panic("unreachable")
		}

		result = wit_types.Err[uint64, StreamError](variant)
	default:
		panic("unreachable")
	}
	result0 := result
	return result0

}
